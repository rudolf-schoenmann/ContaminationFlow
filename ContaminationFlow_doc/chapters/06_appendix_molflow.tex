% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Formulas for new Quantities}\label{chapter:Formulas}

\subsubsection*{Constants}
\begin{equation}
	\begin{split}
	%carbondiameter&=2 \cdot 76\text{E}-12\\
	k_b&=1.38\text{E}-23\\
	h&=6.626\text{E}-34\\
	\end{split}
\end{equation}


\subsubsection*{Variables}
\begin{equation}
	\begin{split}
	%carbondiameter&=2 \cdot 76\text{E}-12\\
	T&=\text{Facet temperature}\\
	\end{split}
\end{equation}

\subsubsection*{Number of carbon equivalent particles of one monolayer}
\begin{equation}
	\label{eq:nmono}
	N_{mono}=\frac{\text{Area of Facet [m$^2$]}}{\text{ProblemDef::particleDia}^2}
\end{equation}

\subsubsection*{Carbon equivalent relative mass factor}
\begin{equation}
	\label{eq:nsurf}
	\begin{split}
	\Delta N_{surf}&=\frac{\text{carbon equivalent gas mass}}{12.011}\\
	%N_{surf}&=\sum\limits_{\substack{\text{adsorbed}\\\text{particles}}}\ \Delta N_{surf}\\
	\end{split}
\end{equation}

\subsubsection*{Covering $\theta^*$}
\begin{equation}
	\begin{split}
		\theta^*&=N_{\text{particles on facet}}
	\end{split}
\end{equation}

\subsubsection*{Coverage $\theta$}
\begin{equation}
	\label{eq:cov}
	\begin{split}
		\theta&=\frac{\theta^*}{N_{mono}/\Delta N_{surf}}
	\end{split}
\end{equation}

%\subsubsection*{Step function $step(x, y_{start}, y_{end}, x_{turning point}, w)$}
%\begin{equation}
%	\label{eq:stepfct}
%	\begin{split}
%		E&=\frac{y_{start}-y_{end}}{2} \cdot \text{tanh}\Big((x_{turning point}-x) \cdot \frac{5.4}{w}\Big) + \frac{y_{start}+y_{end}}{2}
%	\end{split}
%\end{equation}
%
%\subsubsection*{Binding Energy $E$}
%\begin{equation}
%	\label{eq:energy}
%	\begin{split}
%		E&= step(\theta, E_{de}, H_{vap}, 1, W_{tr})\\
%		&=\frac{E_{de}-H_{vap}}{2} \cdot \text{tanh}\Big((1-\theta) \cdot \frac{5.4}{W_{tr}}\Big) + \frac{E_{de}+H_{vap}}{2}
%	\end{split}
%\end{equation}
%
%\subsubsection*{Residence}
%\begin{equation}
%	\label{eq:residence}
%	\begin{split}
%		Frequency&=\frac{k_b T}{h}\\
%		Energy&= E
%	\end{split}
%\end{equation}

\subsubsection*{Binding Energy $E$}
\begin{equation}
	\label{eq:energy}
	E=
	\begin{cases}
		\begin{split}
		E_{de}&, \text{\quad if TODO}\\
		H_{vap}&,  \text{\quad otherwise}
		\end{split}
	\end{cases}
\end{equation}


\subsubsection*{Residence Time}
\begin{equation}
	\label{eq:sojourntime}
	\begin{split}
		A&=\exp\big( - Energy/(k_b T)\big)\\
		residence \ time&= \frac{-\text{ln}(rnd)}{A \cdot Frequency}
	\end{split}
\end{equation}
%
%\subsubsection*{Desorption rate $des$}
%\begin{equation}
%	\label{eq:des}
%	\begin{split}
%	\tau&=\frac{h}{k_b T}\\
%	d&= step(\theta, 1,  0, 1, W_{tr})\\
%	&\\
%	des&=
%	\begin{cases}
%		\begin{split}
%		\frac{1}{\tau}\ \theta^d\ \exp\Big({-\frac{E}{k_b T}}\Big)\cdot \frac{N_{mono}}{\Delta N_{surf}}\cdot k_b T&, \text{\quad if}\ \theta^* > \text{0}\\
%		0&,  \text{\quad otherwise}
%		\end{split}
%	\end{cases}
%	\end{split}
%\end{equation}
\subsubsection*{Step Size $t_{step}$}
\begin{equation}
	\label{eq:tstep}
	\begin{split}
	t_{min}&=\text{ProblemDef::t\_min}\\
	t_{i}&=t_{min} \cdot \exp\big(\text{i}\cdot \ln(\text{ProblemDef::maxTimeS}/T_{min})/\text{ProblemDef::iterationNumber})\big)\\
	t_{step}&=\text{min}\big(t_{currentStep+1}-t_{currentStep}, \text{ProblemDef::t\_max}\big)\\
	\end{split}
\end{equation}

\subsubsection*{Desorption $des$}
\begin{equation}
	\label{eq:des}
	\begin{split}
	\tau_0&=\frac{h}{k_b T}\\
	\tau&=\tau \cdot \exp\Big(\frac{E_de}{k_b T}\Big)\\
	\tau_{ads}&=\tau_0 \cdot \exp\Big(\frac{H_{vap}}{k_b T}\Big)\\
	t_{ads}&=\tau_{ads} \cdot (\theta -1)\\
	&\\
	des&=
	\begin{cases}
		\begin{split}
		0&,  \text{\quad if}\ \theta = 0 \ \text{or}\ T=0\\
		\theta \cdot \big(1-\exp(-t_{step}/\tau)\big)&, \text{\quad else if}\ \theta \leq 1\\
		t_{step}/\tau_{ads}&, \text{\quad else if}\ \theta -1 \geq t_{step}/\tau_{ads}\\
		\theta - 1 + \big(1-\exp(-(t_{step}-t_{ads}/\tau))\big)&, \text{\quad else if}\ \theta -1 < t_{step}/\tau_{ads}\\
		\end{split}
	\end{cases}
	\end{split}
\end{equation}

\subsubsection*{Outgassing $out$}
\begin{equation}
	\label{eq:out}
	out=\frac{\text{Facet outgassing}}{k_b T}
\end{equation}

\subsubsection*{Small covering factor}
\begin{equation}
	\label{eq:smallcov}
	\begin{split}
	mincov&=\text{Smallest covering on a single facet that desorbs}\\
	\text{small covering factor}&=
	\begin{cases}
		\begin{split}
		1,  \text{\quad if}\ mincov \geq \text{ProblemDef::coveringMinThresh}\\
		1+1.1 \cdot (\text{ProblemDef::coveringMinThresh}/mincov), \text{\quad otherwise}\\
		\end{split}
	\end{cases}
	\end{split}
\end{equation}

\subsubsection*{$\text{K}_{\text{real}/\text{virtual}}$}
\begin{equation}
	\label{eq:krealvirt}
	\text{K}_{\text{real}/\text{virtual}}=\frac{\sum\limits_{\text{facets}}\Big(out + des\Big)}{\text{number of total desorbed molecules/small covering factor}}
\end{equation}

\subsubsection*{Error}
\begin{equation}
	\label{eq:error}
	\begin{split}
	\text{error}(counter)&=
	\begin{cases}
	\begin{split}
		inf\quad,\text{ if ($counter$) on facet =0}\\
		\\
		\Big( \frac{1}{\text{($counter$) on facet}} \cdot \frac{1-\text{($counter$) on facet}}{\text{total ($counter$)}} \Big)^{0.5}\quad,\text{else}
	\end{split}
	\end{cases}\\\\
	error\_covering&=\text{error}(\text{adsorbed particles + desorbed particles})\\
	error\_event&=\text{error}(\text{hits + desorbed particles})\\
	\end{split}
\end{equation}

\chapter{Datatypes}
\section{Class Members}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Name&Datatype&Alias\\
\hline
SimulationHistory::coveringList&boost::multiprecision::uint\_128t&covBoost\\
FacetHitBuffer::covering&llong&covLlong\\
FacetProperties::desorption&boost::multiprecision::float128&desBoost\\
Simulation::coveringThreshold&llong&\\
\hline
\end{tabular}
\end{center}
\section{Functions}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Function&Output Datatype&Relevant Input\\
\hline
getCovering()&boost::multiprecision::float128&covBoost\\
getCovering()&llong&covLlong\\
calcCoverage()&boost::multiprecision::float128 or llong&getCovering()\\
calcDesorption()&boost::multiprecision::float128&calcCoverage()\\
%calcDesorptionRate()&boost::multiprecision::float128&calcDesorption()\\
calctotalDesorption()&boost::multiprecision::float128&desBoost\\
GetMoleculesPerTP()&boost::multiprecision::float128&desBoost\\
\hline
\end{tabular}
\end{center}

\chapter{Overview of new Classes and Functions}

%\subsubsection*{Note}
\section{New Classes}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}SimulationHistory}\\
\hline
\rule{0pt}{3ex} coveringList& of class HistoryList, stores covering history\\
\rule{0pt}{3ex} errorList\_event& of class HistoryList, stores error history for events\\
\rule{0pt}{3ex} errorList\_covering& of class HistoryList, stores error history for covering\\
\rule{0pt}{3ex} hitList& of class HistoryList, stores hits for each facet\\
\rule{0pt}{3ex} desorbedList& of class HistoryList, stores desorbed particles for each facet\\
\rule{0pt}{3ex} startNewParticle& Determines wether to create a new particle for next iteration\\
\rule{0pt}{3ex} numFacet& number of Facets\\
\rule{0pt}{3ex} numSubProcess& number of sub processes used for simulation\\
\rule{0pt}{3ex} \multirow{2}{*}{nbDesorbed\_old}& number of total desorbed molecules of previous iteration\\
&\qquad$\Rightarrow$ To calculate difference between consecutive iterations\\
\rule{0pt}{3ex} flightTime& Simulated flight time for iteration\\
\rule{0pt}{3ex} nParticles& Simulated particles for iteration\\
\rule{0pt}{3ex} lastTime& Total simulated time = last time in Lists\\
\rule{0pt}{3ex} currentStep& step of logarithmic time step calculation in \codew{getStepSize()}\\
\rule{0pt}{3ex} stepSize&current step size\\
\hline
\rule{0pt}{3ex} updateHistory()& Reset and update from hitbuffer\\
\rule{0pt}{3ex} appendList()& Updates coveringList from hitbuffer\\
\rule{0pt}{3ex} print()& Print to terminal\\
\rule{0pt}{3ex} write()& Write to file\\
\hline

\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}HistoryList}\\
\hline
\rule{0pt}{3ex} pointInTimeList& list containing history respective facet values\\
\rule{0pt}{3ex} currentList& list containing facet values at current step\\
\rule{0pt}{3ex} currIt& current iteration number\\
\hline
%\rule{0pt}{3ex} reset()& Resets lists\\
%\rule{0pt}{3ex} initCurrent()& Initializes size of lists\\
\rule{0pt}{3ex} appendCurrent()& Appends currentList to pointInTimeList\\
\rule{0pt}{3ex} appendList()& Append input list to pointInTimeList\\
\rule{0pt}{3ex} convertTime()& Converts time for better clarity\\
\rule{0pt}{3ex} printCurrent()& Print currentList as table to terminal, optional message\\
\rule{0pt}{3ex} print()& Print pointInTimeList as table to terminal, optional msg\\
\rule{0pt}{3ex} write(), read()& Write to file, read from file\\
%\rule{0pt}{3ex} empty()& Checks if pointintime\_list is empty\\
\rule{0pt}{3ex} set/getCurrent()& Set/get value of desired facet in currentList\\
\rule{0pt}{3ex} setLast(), getLast()& Set/get value of desired facet from pointInTimeList\\
\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}ProblemDef}\\
\hline
\rule{0pt}{3ex} resultpath& Path of result folder\\
\rule{0pt}{3ex} outFile& Path of file that contains terminal output\\
\rule{0pt}{3ex} loadbufferPath& Path of loadbuffer file\\
\rule{0pt}{3ex} hitbufferPath& Path of hitbuffer file\\
\rule{0pt}{3ex} simulationTime, unit& \multirow{2}{*}{Computation time of each iteration in milliseconds}\\
\enskip$\Rightarrow$simulationTimeMS&\\
\rule{0pt}{3ex} maxTime, maxUnit& \multirow{2}{*}{Maximal total simulated time in seconds}\\
\enskip$\Rightarrow$maxTimeS&\\
\rule{0pt}{3ex} iterationNumber& Number of iterations\\
\rule{0pt}{3ex} particleDia& Diameter of particles\\
%\rule{0pt}{3ex}  d& Parameter to calculate desorption rate, see equation \ref{eq:des}\\
\rule{0pt}{3ex}  E\_de, H\_vap& Parameters to calculate binding energy, see equation \ref{eq:energy}\\ %W\_tr
\rule{0pt}{3ex}  sticking&  Sticking factor for all facets\\
%\rule{0pt}{3ex}  coveringLimit&  Covering limit for zero desorption \\
\rule{0pt}{3ex}  targetParticles/-Error&  Target values for each iteration\\
\rule{0pt}{3ex}  hitRatioLimit&  threshold of hitratio at which hits are ignored\\
\rule{0pt}{3ex}  coveringMinThresh&  Minimum covering, multiplication to this if covering low\\
\rule{0pt}{3ex}  t\_min, t\_max&  Minimum/ Maximum step size\\
\rule{0pt}{3ex}  maxSimPerIt&  Maximun simulation steps per iteration\\
\rule{0pt}{3ex}  histSize&  Size of history lists (most recent values in memory)\\
\rule{0pt}{3ex}  vipFacets&  alterning: vip facet and target error, e.g.\ 1 0.001 3 0.002\\
\hline
\rule{0pt}{3ex} readInputfile()& Initialization from input file\\
\rule{0pt}{3ex} printInputfile()& Print to terminal\\
\hline
\end{tabular}
\end{center}

\section{New Functions}
\subsection{molflowlinux\_main.cpp}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Preprocessing}\\
\hline
%\rule{0pt}{3ex} MPI\_Init()& Initialize MPI\\
\rule{0pt}{3ex} \multirow{2}{*}{parametercheck()}& Checks validity of input parameters from input file\\& Defines values for ProblemDef object \codew{p} \\
\rule{0pt}{3ex} importBuff()& Import load- and hitbuffer to main process\\
\rule{0pt}{3ex} MPI\_Bcast()& Send loadbuffer to sub processes\\
\rule{0pt}{3ex} LoadSimulation()& Load geometry from loadbuffer\\
\rule{0pt}{3ex} initCoveringThresh()& Initialize covering threshold\\
\rule{0pt}{3ex} \codew{simHistory}& Initialize SimulationHistory object\\
\hline
\multicolumn{2}{l}{}\\
%\end{tabular}
%\end{center}
%
%\begin{center}
%\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Simulation Loop}\\
\hline
\rule{0pt}{3ex} initbufftozero()& Reset all hitbuffer counters except covering\\
\rule{0pt}{3ex} \multirow{2}{*}{MPI\_Bcast()}& Send \codew{simHistory$\rightarrow$coveringList} and \\&\codew{simHistory$\rightarrow$currentStep} to sub processes\\
\rule{0pt}{3ex} setCoveringThreshold()& Sets covering threshold for each facet\\
\rule{0pt}{3ex} UpdateSojourn()& Sets sojourn variables for each facet\\
\rule{0pt}{3ex} UpdateDesorptionRate()& Sets desorption for each facet, ends simulation if 0\\
\rule{0pt}{3ex} checkSmallCovering()& multiplies covering to reach threshold if covering small\\
\rule{0pt}{3ex} simulateSub()& Simulation on sub processes\\
\rule{0pt}{3ex} MPI\_Send(), MPI\_Recv()& Send sub hitbuffer to main process\\
\rule{0pt}{3ex} \multirow{2}{*}{UpdateMCMainHits()}& Add simulation results from sub hitbuffer\\& to main hitbuffer\\
%\rule{0pt}{3ex} UndoSmallCovering()& Divide covering if it was multiplied before\\
\rule{0pt}{3ex} UpdateErrorMain()& Calculate and save error of iteration to simHistory\\
\rule{0pt}{3ex} UpdateCovering()& Calculate and save new covering to simHistory\\
\rule{0pt}{3ex} UpdateCoveringphys()& Saves current covering to hitbuffer\\
\rule{0pt}{3ex} \codew{simHistory$\rightarrow$coveringList}& \multirow{2}{*}{Adapt size to \codew{p$\rightarrow$histSize} if necessary}\\ \codew{simHistory$\rightarrow$errorList}&\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{2.5ex}End simulation if maximum simulation time is reached}\\
\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Postprocessing}\\
\hline
\rule{0pt}{3ex} exportBuff()& Export final hitbuffer\\
\rule{0pt}{3ex} simHistory$\rightarrow$write()& Export simulation history\\
%\rule{0pt}{3ex} MPI\_Finalize()& Close MPI\\
\hline
\end{tabular}
\end{center}
\subsection{SimulationLinux.cpp}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}simulateSub()}\\
\hline
\rule{0pt}{3ex}\multirow{2}{*}{ targetParticles, targetError}& Calculate target values from overall target\\& and number sub processes\\
\rule{0pt}{3ex}\multirow{2}{*}{ \codew{simHistory->updateHistory()}}& Reset and update SimulationHistory object\\& from \codew{sHandle}\\
\rule{0pt}{3ex}\multirow{2}{*}{ smallCoveringFactor}& If covering is small: Covering is multiplied by\\ & smallCoveringFactor to improve statistics\\
%\rule{0pt}{3ex} StartSimulation()& Create first particle\\
\rule{0pt}{3ex} SimulationRun()& Simulate for desired simulation time\\
\rule{0pt}{3ex} UpdateError()& Calculate current error of sub process\\
\rule{0pt}{3ex} \multirow{2}{*}{CheckErrorSub()}& Checks if normal facets reached targetError\\& and if vip facets reached own target\\
\rule{0pt}{3ex} UpdateMCSubHits()& Save simulation results to hitbuffer\\
%\rule{0pt}{3ex} ResetTmpCounters()& Reset simulation for next iteration\\
\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Small covering}\\
\hline
\rule{0pt}{3ex} \multirow{2}{*}{CheckSmallCovering()}& If covering is small, find smallCoveringFactor \\& to reach \codew{p$\rightarrow$coveringMinThresh}\\
\rule{0pt}{3ex} Undo multiplication& In \codew{UpdateCovering()}\\
\hline
\end{tabular}
\end{center}

\subsection{Iteration.cpp}
\begin{center}
\begin{tabular}{|l|l|}
%\hline
%\multicolumn{2}{|c|}{\rule{0pt}{3ex}Calculation of time\_step}\\
%\hline
%\rule{0pt}{3ex} estimateAverageFlightTime()& Average flight time, see equation \ref{eq:tavg}\\
%\rule{0pt}{3ex} estimateTmin\_RudiTest()& Average path length/average velocity\\
%\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Set Covering Threshold to avoid negative covering}\\
\hline
\rule{0pt}{3ex} initCoveringThresh()& Initializes size of covering threshold vector\\
\rule{0pt}{3ex} setCoveringThreshold()& Sets covering threshold for each facet\\
\hline
\end{tabular}
\end{center}

\subsection{Buffer.cpp}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Buffer functions}\\
\hline
\rule{0pt}{3ex}  \multirow{2}{*}{Databuff struct()}& signed int size \\& BYTE *buff\\
\hline
\rule{0pt}{3ex} checkReadable()& Checks if file can be opened for reading\\
\rule{0pt}{3ex} checkWriteable()&  Checks if file can be openend or created for writing\\
\rule{0pt}{3ex} importBuff()& Imports buffer file to Databuff struct\\
\rule{0pt}{3ex} exportBuff()&  Exports Databuff struct to buffer file\\
\hline
\end{tabular}
\end{center}

\subsection{Calculations in SimulationCalc.cpp etc.}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}SimulationCalc.cpp}\\
\hline
\rule{0pt}{3ex} getCovering()& Get covering from hitbuffer or \codew{simHistory}\\
\rule{0pt}{3ex} getHits()& Get number of hits from hitbuffer\\
\rule{0pt}{3ex} \multirow{2}{*}{getnbDesorbed()}& Get number of total desorbed\\
&molecules from hitbuffer\\
\rule{0pt}{3ex} \multirow{2}{*}{getnbAdsorbed()}& Get number of total adsorbed\\
&molecules from hitbuffer\\
\rule{0pt}{3ex} calcNmono()& see equation \ref{eq:nmono} \\
\rule{0pt}{3ex} calcdNsurf()& see equation \ref{eq:nsurf} \\
\rule{0pt}{3ex} calcCoverage()& see equation \ref{eq:cov} \\
%\rule{0pt}{3ex} calcStep()& see equation \ref{eq:stepfct} \\
\rule{0pt}{3ex} calcEnergy()& see equation \ref{eq:energy} \\
\rule{0pt}{3ex} calcStickingnew()& sets sticking coefficient to p$\rightarrow$sticking \\
\rule{0pt}{3ex} calcDesorption()& see equation \ref{eq:des} \\
\rule{0pt}{3ex} GetMoleculesPerTP()& see equation \ref{eq:krealvirt} \\
\rule{0pt}{3ex} \multirow{2}{*}{calctotalDesorption}& calculates desorption for\\
&\codew{startFromSource()} \\
\rule{0pt}{3ex} calcPressure()& TODO has to be verified \\
\rule{0pt}{3ex} calcParticleDensity()& TODO has to be verified \\
\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}worker.cpp}\\
\hline
\rule{0pt}{3ex}\multirow{2}{*}{CalcTotalOutgassingWorker()}& see equation \ref{eq:out}, calculates outgassing\\
&for \codew{startFromSource()} \\
\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}SimulationLinux.cpp}\\
\hline
\rule{0pt}{3ex} convertunit()& Converts simutime*unit to milliseconds\\
\hline
\end{tabular}
\end{center}
\newpage
\subsection{UpdateSubProcess.cpp}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Update sHandle paramters from hitbuffer}\\
\hline
\rule{0pt}{3ex} UpdateSticking()& Updates sticking\\
\rule{0pt}{3ex} UpdateDesorptionRate()& Updates desorption \\
\rule{0pt}{3ex} UpdateSojourn()& Enables sojourn time\\% Updates sojourn frequency and energy \\
\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Error calculations}\\
\hline
\rule{0pt}{3ex} \multirow{3}{*}{UpdateErrorSub()}& Calculates error per facet, see equation \ref{eq:error}\\&Saves to \codew{simHistory$\rightarrow$ errorList\_covering}\\ & and \codew{simHistory$\rightarrow$ errorList\_event}\\
\rule{0pt}{3ex} \multirow{2}{*}{UpdateError()}& Sums up error of normal facets \& weights by facet area\\& Currently covering error instead of event error\\
\rule{0pt}{3ex} CheckErrorSub()& Checks if normal \& vip facets reached respective target\\
\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Update hitbuffer}\\
\hline
\rule{0pt}{3ex} initbufftozero()& Sets hitbuffer except covering to zero\\
\rule{0pt}{3ex} UpdateMCSubHits()& Saves simulation results from sHandle into hitbuffer\\
\hline
\end{tabular}
\end{center}

\subsection{UpdateMainProcess.cpp}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Update main hitbuffer from sub hitbuffer}\\
\hline
\rule{0pt}{3ex}  \multirow{2}{*}{UpdateMCMainHits()}& Add simulation results from sub hitbuffer\\& to main hitbuffer\\
\hline
\multicolumn{2}{l}{}\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Update real covering in hitbuffer}\\
\hline
\rule{0pt}{3ex} getStepSize()& Calculates step size for current step, see equation \ref{eq:tstep}\\
%\rule{0pt}{3ex} {manageStepSize()}&  Adapts step size if desRate $\cdot$ step size $>$ than covering\\
\rule{0pt}{3ex} \multirow{2}{*}{UpdateCovering()}& Uses Krealvirt to calculate new covering\\
& Saved to \codew{simHistory$\rightarrow$coveringList}\\
\rule{0pt}{3ex} UpdateCoveringphys()& Saves current real covering to hitbuffer\\
\rule{0pt}{3ex} \multirow{3}{*}{UpdateErrorMain()}& Calculates total error for each facet, see equation \ref{eq:error}\\
& Saves to \codew{simHistory$\rightarrow$errorList\_event}\\& and \codew{simHistory$\rightarrow$errorList\_covering}\\
\rule{0pt}{3ex} \multirow{2}{*}{CalcPerIteration()}&  Calculates total error (covering and event)\\& and covering over all facets per iteration\\
\hline
\end{tabular}
\end{center}


%\chapter{Deprecated Functionalities}
%
%The following functionalities are deprecated. They can still be found in the code, but will not be updated or used as of now.
%
%\subsubsection{Application with standard parameters}
%Call of ContaminationFlow Linux application with standard parameters in the command line:
%
%\code{
%\$ module load mpi\\
%\$ mpirun -n N ContaminationFlow loadbuffer hitbuffer save simulationtime unit}
%\smallskip
%with the following command line parameters:
%\begin{itemize}[noitemsep,topsep=0pt]
%\item n: desired number of worker processes; simulation on K=N-1 worker processes
%\item MolflowLinux: path to application, e.g.\ \codew{\textasciitilde/MolflowLinux/Debug/MolflowLinux}
%\item loadbuffer: path to loadbuffer file, contains geometry, e.g.\ \codew{\textasciitilde/loadbuffer}
%\item hitbuffer: path to hitbuffer file, contains counters, etc., e.g.\ \codew{\textasciitilde/hitbuffer}
%%\item resultbuffer: path to resultbuffer file, where the final hitbuffer is exported to,\\ e.g.\ \codew{\textasciitilde/resultbuffer}
%\item save: determines whether result directory is created (1: true, 0:false), default:1
%\item simulationtime: simulation time, e.g.\ \codew{2.5}
%\item unit (optional): simulation time unit, e.g.\ \codew{min}; default: \codew{s}
%\end{itemize}
%
%\subsubsection{Estimation of time step \codew{$T_{min}$}}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Determines minimum timestep for simulation, average time between outgassing/desorption and adsorption
%\item $T_{min}$ computed in \codew{Iteration.cpp} file in \codew{estimateAverageFlightTime()} using simulationHistory: $\text{flightTime}/\text{nParticles}$ 
%\end{itemize}
%
%\subsubsection{Management of time step \codew{$T_{min}$}}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Currently not used
%\item Chooses larger value between \codew{estimateAverageFlightTime()} and \codew{getStepSize()}
%\item Checks whether current time step would cause covering to get negative
%\item Adapts time step if needed
%\item Increments \codew{SimulationHistory::currentStep} if \codew{getStepSize()} chosen and not decreased
%\item Management in \codew{UpdateMainProcess.cpp} file in \codew{manageTimeStep($\cdot$)}
%\end{itemize}
%
%\subsubsection{Management of Simulation Time}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Increases simulation time (=computation time) per iteration if not enough particles desorbed
%\item Adapts simulation time if needed
%\item If enough desorption: compute maximum ratio $step size/computation time$
%\item If not enough desorption: adapt computation time using ration $step size/computation time$
%\item Management in \codew{UpdateMainProcess.cpp} file in \codew{manageSimulationTime($\cdot$)}
%\end{itemize}
