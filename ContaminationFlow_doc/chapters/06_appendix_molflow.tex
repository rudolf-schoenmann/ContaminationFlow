% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Formulas for new Quantities}\label{chapter:Formulas}

\subsubsection*{Constants}
\begin{equation}
	\begin{split}
	carbondiameter&=2 \cdot 76\text{E}-12\\
	K_b&=1.38\text{E}-23\\
	h&=6.626\text{E}-34\\
	\end{split}
\end{equation}

\subsubsection*{Number of carbon equivalent particles of one monolayer}
\begin{equation}
	\label{eq:nmono}
	N_{mono}=\frac{\text{Area of Facet [m$^2$]}}{carbondiameter^2}
\end{equation}

\subsubsection*{Carbon equivalent relative mass factor}
\begin{equation}
	\label{eq:nsurf}
	\begin{split}
	\Delta N_{surf}&=\frac{\text{carbon equivalent gas mass}}{12.011}\\
	%N_{surf}&=\sum\limits_{\substack{\text{adsorbed}\\\text{particles}}}\ \Delta N_{surf}\\
	\end{split}
\end{equation}

\subsubsection*{Covering $\theta^*$}
\begin{equation}
	\begin{split}
		\theta^*&=N_{\text{particles on facet}}
	\end{split}
\end{equation}

\subsubsection*{Coverage $\theta$}
\begin{equation}
	\label{eq:cov}
	\begin{split}
		\theta&=\frac{\theta^*}{N_{mono}/\Delta N_{surf}}
	\end{split}
\end{equation}

%\subsubsection*{Sticking factor $sc$}
%\begin{equation}
%	\label{eq:sc}
%	sc(\theta)=
%	\begin{cases}
%		\begin{split}
%		1&, \text{\quad if}\ \theta^* \geq 100\\
%		0&,  \text{\quad otherwise}
%		%(s_1 (1-\theta) + s_2 \theta) \cdot (1 -  \exp({-\frac{E_{ad}}{K_b T}}))&, \text{\quad if}\ \theta < 1\\
%		%s_2  \cdot (1 -  \exp({-\frac{E_{ad}}{K_b T}}))&,  \text{\quad otherwise}.
%		\end{split}
%	\end{cases}
%\end{equation}

\subsubsection*{Energy $E$}
\begin{equation}
	\label{eq:energy}
	\begin{split}
		E&=\frac{E_{de}-H_{vap}}{2} \cdot \text{tanh}\Big((1-coverage) \cdot \frac{5.4}{W_{tr}}\Big) + \frac{E_{de}+H_{vap}}{2}
	\end{split}
\end{equation}

\subsubsection*{Sojourn}
\begin{equation}
	\label{eq:sojourn}
	\begin{split}
		Frequency&=\frac{K_b T}{h}\\
		Energy&= E
	\end{split}
\end{equation}

\subsubsection*{Desorption rate $des$}
\begin{equation}
	\label{eq:des}
	\begin{split}
	\tau&=\frac{h}{K_b T}\\
	&\\
	des&=
	\begin{cases}
		\begin{split}
		\frac{1}{\tau}\ \theta^d\ \exp\Big({-\frac{E}{K_b T}}\Big)\cdot \frac{N_{mono}}{\Delta N_{surf}}\cdot K_b T&, \text{\quad if}\ \theta^* \geq \text{covering limit}\\
		0&,  \text{\quad otherwise}
		\end{split}
	\end{cases}
	\end{split}
\end{equation}

\subsubsection*{Outgassing rate $out$}
\begin{equation}
	\label{eq:out}
	out=\frac{\text{Facet outgassing}}{K_b T}
\end{equation}

\subsubsection*{$\text{K}_{\text{real}/\text{virtual}}$}
\begin{equation}
	\label{eq:krealvirt}
	\text{K}_{\text{real}/\text{virtual}}=\frac{\sum\limits_{\text{facets}}\Big(out + \frac{des}{K_b T}\Big)}{\text{number of total desorbed molecules}}
\end{equation}

%\subsubsection*{Average Flight Time $T_{avg}$}
%\begin{equation}
%	\label{eq:tavg}
%	T_{avg}=\frac{\text{Total flight time}}{\text{Total number of particles}}
%\end{equation}

\subsubsection*{Step Size $T_{step}$}
\begin{equation}
	\label{eq:tstep}
	\begin{split}
	T_{min}&=\text{Tmin}\\
	T_{i}&=T_{min} \cdot \exp\Big(\text{i}\cdot \ln(\text{max. simulation time}/T_{min})/\text{max. \# of steps})\Big)\\
	T_{step}&=T_{currentStep+1}-T_{currentStep}\\
	\end{split}
\end{equation}

%\subsubsection*{Simulated Time step}
%\begin{equation}
%	\label{eq:timestep}
%	\text{time}\_\text{step}=
%	\begin{cases}
%		\begin{split}
%		T_{avg}&, \text{\quad if}\ T_{avg} \geq T_{step}\\
%		T_{step}&,  \text{\quad otherwise}
%		\end{split}
%	\end{cases}
%\end{equation}

\subsubsection*{Error}
\begin{equation}
	\label{eq:error}
	\begin{split}
		error&=\Big( \frac{1}{\text{(hits + desorbed) on facet}} \cdot \frac{1-\text{(hits + desorbed) on facet}}{\text{total (hits + desorbed)}} \Big)^{0.5}
	\end{split}
\end{equation}

\chapter{Overview of new Classes and Functions}
\section{New Classes}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}SimulationHistory}\\
\hline
\rule{0pt}{3ex} coveringList& of class HistoryList, stores covering history\\
\rule{0pt}{3ex} errorList& of class HistoryList, stores error history\\
\rule{0pt}{3ex} hitList& of class HistoryList, stores hits for each facet\\
\rule{0pt}{3ex} desorbedList& of class HistoryList, stores desorbed particles for each facet\\
\rule{0pt}{3ex} numFacet& number of Facets\\
\rule{0pt}{3ex} numSubProcess& number of sub processes used for simulation\\
\rule{0pt}{3ex} \multirow{2}{*}{nbDesorbed\_old}& number of total desorbed molecules of previous iteration\\
&\qquad$\Rightarrow$ To calculate difference between consecutive iterations\\
\rule{0pt}{3ex} flightTime& number of Facets\\
\rule{0pt}{3ex} nParticles& Simulated flight time for iteration\\
\rule{0pt}{3ex} numFacet& Simulated particles for iteration\\
\rule{0pt}{3ex} lastTime& Total simulated time = last time in Lists\\
\rule{0pt}{3ex} currentStep& step of logarithmic time step calculation in \codew{getStepSize()}\\
\hline
\rule{0pt}{3ex} updateHistory()& Reset and update from hitbuffer\\
\rule{0pt}{3ex} appendList()& Updates coveringList from hitbuffer\\
\rule{0pt}{3ex} print()& Print to terminal\\
\rule{0pt}{3ex} write()& Write to file\\
\hline

\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}HistoryList}\\
\hline
\rule{0pt}{3ex} pointInTimeList& list containing history respective facet values\\
\rule{0pt}{3ex} currentList& list containing facet values at current step\\
\hline
%\rule{0pt}{3ex} reset()& Resets lists\\
%\rule{0pt}{3ex} initCurrent()& Initializes size of lists\\
\rule{0pt}{3ex} appendCurrent()& Appends currentList to pointInTimeList\\
\rule{0pt}{3ex} appendList()& Append input list to pointInTimeList\\
\rule{0pt}{3ex} convertTime()& Converts time for better clarity\\
\rule{0pt}{3ex} print()& Print pointInTimeList as table to terminal, optional message\\
\rule{0pt}{3ex} printCurrent()& Print currentList as table to terminal, optional message\\
\rule{0pt}{3ex} write(), read()& Write to file, read from file\\
%\rule{0pt}{3ex} empty()& Checks if pointintime\_list is empty\\
\rule{0pt}{3ex} setCurrentList()& Set value of desired facet in currentList\\
\rule{0pt}{3ex} getCurrent()& Get value of desired facet from currentList\\
\rule{0pt}{3ex} setLast()& Set value of desired facet from pointInTimeList\\
\rule{0pt}{3ex} getLast()& Get value of desired facet from pointInTimeList\\
\hline
\multicolumn{2}{l}{}\\[1ex]
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}ProblemDef}\\
\hline
\rule{0pt}{3ex} resultpath& Path of result folder\\
\rule{0pt}{3ex} outFile& Path of file that contains terminal output\\
\rule{0pt}{3ex} loadbufferPath& Path of loadbuffer file\\
\rule{0pt}{3ex} hitbufferPath& Path of hitbuffer file\\
\rule{0pt}{3ex} simulationTime, unit& \multirow{2}{*}{Computation time of each iteration in milliseconds}\\
\enskip$\Rightarrow$simulationTimeMS&\\
\rule{0pt}{3ex} maxTime, maxUnit& \multirow{2}{*}{Maximal total simulated time in seconds}\\
\enskip$\Rightarrow$maxTimeS&\\
\rule{0pt}{3ex} iterationNumber& Number of iterations\\
\rule{0pt}{3ex}  d& Parameter to calculate desorption rate, see equation \ref{eq:des}\\
\rule{0pt}{3ex}  E\_de, H\_vap, W\_tr& Parameters to calculate binding energy, see equation \ref{eq:energy}\\
\rule{0pt}{3ex}  sticking&  Sticking factor for all facets\\
\rule{0pt}{3ex}  coveringLimit&  Covering limit for zero desorption \\
\rule{0pt}{3ex}  targetParticles/-Error&  Target values for each iteration\\
\rule{0pt}{3ex}  hitRatioLimit&  Limit of hitratio to ignore hits\\
\rule{0pt}{3ex}  Tmin&  Minimum step size\\
\hline
\rule{0pt}{3ex} readInputfile()& Initialization from input file\\
\rule{0pt}{3ex} printInputfile()& Print to terminal\\
\hline
\end{tabular}
\end{center}

\section{New Functions}
\subsection{molflowlinux\_main.cpp}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Preprocessing}\\
\hline
\rule{0pt}{3ex} \multirow{2}{*}{parametercheck()}& Checks validity of input parameters from input file\\& Defines values for ProblemDef object \codew{p} \\
\rule{0pt}{3ex} importBuff()& Import load- and hitbuffer to main process\\
\rule{0pt}{3ex} MPI\_Bcast()& Send loadbuffer to sub processes\\
\rule{0pt}{3ex} LoadSimulation()& Load geometry from loadbuffer\\
\rule{0pt}{3ex} initCoveringThresh()& Initialize covering threshold\\
\rule{0pt}{3ex} \codew{simHistory}& Initialize SimulationHistory object\\
\hline
\multicolumn{2}{l}{}\\[1ex]
%\end{tabular}
%\end{center}
%
%\begin{center}
%\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Simulation Loop}\\
\hline
\rule{0pt}{3ex} initbufftozero()& Reset all hitbuffer counters except covering\\
\rule{0pt}{3ex} \multirow{2}{*}{MPI\_Bcast()}& Send hitbuffer and \codew{simHistory$\rightarrow$currentStep}\\& to sub processes\\
\rule{0pt}{3ex} setCoveringThreshold()& Sets covering threshold for each facet\\
\rule{0pt}{3ex} UpdateDesorptionRate()& Sets desorption for each facet\\
\rule{0pt}{3ex} UpdateSojourn()& Sets sojourn variables for each facet\\
\rule{0pt}{3ex} simulateSub()& Simulation on sub processes\\
\rule{0pt}{3ex} MPI\_Send(), MPI\_Recv()& Send sub hitbuffer to main process\\
\rule{0pt}{3ex} \multirow{2}{*}{UpdateMCMainHits()}& Add simulation results from sub hitbuffer\\& to main hitbuffer\\
\rule{0pt}{3ex} UpdateErrorMain()& Calculate and save error of iteration to simHistory\\
\rule{0pt}{3ex} UpdateCovering()& Calculate and save new covering to simHistory\\
\rule{0pt}{3ex} UpdateCoveringphys()& Saves current covering to hitbuffer\\
\hline
\multicolumn{2}{|c|}{\rule{0pt}{2.5ex}End simulation if maximum simulation time is reached}\\
\hline
\multicolumn{2}{l}{}\\[1ex]
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Postprocessing}\\
\hline
\rule{0pt}{3ex} exportBuff()& Export final hitbuffer\\
\rule{0pt}{3ex} simHistory$\rightarrow$write()& Export simulation history\\
\hline
\end{tabular}
\end{center}
\subsection{SimulationLinux.cpp}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}simulateSub()}\\
\hline
\rule{0pt}{3ex}\multirow{2}{*}{targetParticles, targetError}& Calculate target values from overall target\\& and number sub processes\\
\rule{0pt}{3ex}\multirow{2}{*}{\codew{simHistory->updateHistory()}}& Reset and Update SimulationHistory object\\& from hitbuffer\\
%\rule{0pt}{3ex} StartSimulation()& Create first particle\\
\rule{0pt}{3ex} SimulationRun()& Simulate for desired simulation time\\
\rule{0pt}{3ex} \multirow{2}{*}{UpdateError()}& Calculate current error of sub process\\& End simulation if targets or covthresh reached\\
\rule{0pt}{3ex} UpdateMCSubHits()& Save simulation results to hitbuffer\\
%\rule{0pt}{3ex} ResetTmpCounters()& Reset simulation for next iteration\\
\hline
\end{tabular}
\end{center}

\subsection{Calculations in SimulationCalc.cpp etc.}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}SimulationCalc.cpp}\\
\hline
\rule{0pt}{3ex} getCovering()& Get covering from hitbuffer\\
\rule{0pt}{3ex} getHits()& Get number of hits from hitbuffer\\
\rule{0pt}{3ex} \multirow{2}{*}{getnbDesorbed()}& Get number of total desorbed\\
&molecules from hitbuffer\\
\rule{0pt}{3ex} calcNmono()& see equation \ref{eq:nmono} \\
\rule{0pt}{3ex} calcdNsurf()& see equation \ref{eq:nsurf} \\
\rule{0pt}{3ex} calcCoverage()& see equation \ref{eq:cov} \\
\rule{0pt}{3ex} calcEnergy()& see equation \ref{eq:energy} \\
\rule{0pt}{3ex} calcStickingnew()& sets sticking coefficient to p$\rightarrow$sticking \\
\rule{0pt}{3ex} calcDesorption(), calcDesorptionRate()& see equation \ref{eq:des} \\
\rule{0pt}{3ex} GetMoleculesPerTP()& see equation \ref{eq:krealvirt} \\
\rule{0pt}{3ex} \multirow{2}{*}{calctotalDesorption}& calculates desorption for\\
&\codew{startFromSource()} \\
\rule{0pt}{3ex} calcPressure(), calcParticleDensity()& TODO has to be verified \\
\hline
\multicolumn{2}{l}{}\\[1ex]
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}worker.cpp}\\
\hline
\rule{0pt}{3ex}\multirow{2}{*}{CalcTotalOutgassingWorker()}& see equation \ref{eq:out}, calculates outgassing\\
&for \codew{startFromSource()} \\
\hline
\multicolumn{2}{l}{}\\[1ex]
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}SimulationLinux.cpp}\\
\hline
\rule{0pt}{3ex} covertunit()& Converts simutime*unit to milliseconds\\
\hline
\end{tabular}
\end{center}

\subsection{UpdateSubProcess.cpp}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Update sHandle paramters from hitbuffer}\\
\hline
\rule{0pt}{3ex} UpdateSticking()& Updates sticking\\
\rule{0pt}{3ex} UpdateDesorptionRate()& Updates desorption rate \\
\rule{0pt}{3ex} UpdateSojourn()& Updates sojourn freqency and energy \\
\rule{0pt}{3ex} UpdateError()& Updates  error for current iteration, see equation \ref{eq:error}\\
\hline
\multicolumn{2}{l}{}\\[1ex]
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Update hitbuffer}\\
\hline
\rule{0pt}{3ex} initbufftozero()& Sets hitbuffer except covering to zero\\
\rule{0pt}{3ex} UpdateMCSubHits()& Saves simulation results from sHandle into hitbuffer\\
\hline
\end{tabular}
\end{center}

\subsection{UpdateMainProcess.cpp}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Update main hitbuffer from sub hitbuffer}\\
\hline
\rule{0pt}{3ex}  \multirow{2}{*}{UpdateMCMainHits()}& Add simulation results from sub hitbuffer\\& to main hitbuffer\\
\hline
\multicolumn{2}{l}{}\\[1ex]
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Update real covering in hitbuffer}\\
\hline
\rule{0pt}{3ex} getStepSize()& Calculates step size for current step, see equation \ref{eq:tstep}\\
\rule{0pt}{3ex} {manageStepSize()}&  Adapts step size if desorptionrate $\cdot$ step size $>$ than covering\\
\rule{0pt}{3ex} \multirow{2}{*}{UpdateCovering()}& Uses step size and Krealvirt to calculate new covering\\
& Saved to \codew{simHistory$\rightarrow$coveringList}\\
\rule{0pt}{3ex} UpdateCoveringphys()& Saves current real covering to hitbuffer\\
\rule{0pt}{3ex} \multirow{2}{*}{UpdateErrorMain()}& Calculates total error, see equation \ref{eq:error}\\
& Saved to \codew{simHistory$\rightarrow$errorList}\\
\rule{0pt}{3ex} {CalcPerIteration()}&  Calculates total error and covering over all facets per iteration\\
\hline
\end{tabular}
\end{center}

\subsection{Iteration.cpp}
\begin{center}
\begin{tabular}{|l|l|}
%\hline
%\multicolumn{2}{|c|}{\rule{0pt}{3ex}Calculation of time\_step}\\
%\hline
%\rule{0pt}{3ex} estimateAverageFlightTime()& Average flight time, see equation \ref{eq:tavg}\\
%\rule{0pt}{3ex} estimateTmin\_RudiTest()& Average path length/average velocity\\
%\hline
\multicolumn{2}{l}{}\\[1ex]
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Set Covering Threshold to avoid negative covering}\\
\hline
\rule{0pt}{3ex} initCoveringThresh()& Initializes size of covering threshold vector\\
\rule{0pt}{3ex} setCoveringThreshold()& Sets covering threshold for each facet\\
\hline
\end{tabular}
\end{center}

\subsection{Buffer.cpp}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\rule{0pt}{3ex}Buffer functions}\\
\hline
\rule{0pt}{3ex}  \multirow{2}{*}{Databuff struct()}& signed int size \\& BYTE *buff\\
\hline
\rule{0pt}{3ex} checkReadable()& Checks if file can be opened for reading\\
\rule{0pt}{3ex} checkWriteable()&  Checks if file can be openend or created for writing\\
\rule{0pt}{3ex} importBuff()& Imports buffer file to Databuff struct\\
\rule{0pt}{3ex} exportBuff()&  Exports Databuff struct to buffer file\\
\hline
\end{tabular}
\end{center}

%\chapter{Deprecated Functionalities}
%
%The following functionalities are deprecated. They can still be found in the code, but will not be updated or used as of now.
%
%\subsubsection{Application with standard parameters}
%Call of ContaminationFlow Linux application with standard parameters in the command line:
%
%\code{
%\$ module load mpi\\
%\$ mpirun -n N ContaminationFlow loadbuffer hitbuffer save simulationtime unit}
%\smallskip
%with the following command line parameters:
%\begin{itemize}[noitemsep,topsep=0pt]
%\item n: desired number of worker processes; simulation on K=N-1 worker processes
%\item MolflowLinux: path to application, e.g.\ \codew{\textasciitilde/MolflowLinux/Debug/MolflowLinux}
%\item loadbuffer: path to loadbuffer file, contains geometry, e.g.\ \codew{\textasciitilde/loadbuffer}
%\item hitbuffer: path to hitbuffer file, contains counters, etc., e.g.\ \codew{\textasciitilde/hitbuffer}
%%\item resultbuffer: path to resultbuffer file, where the final hitbuffer is exported to,\\ e.g.\ \codew{\textasciitilde/resultbuffer}
%\item save: determines whether result directory is created (1: true, 0:false), default:1
%\item simulationtime: simulation time, e.g.\ \codew{2.5}
%\item unit (optional): simulation time unit, e.g.\ \codew{min}; default: \codew{s}
%\end{itemize}
%
%\subsubsection{Estimation of time step \codew{$T_{min}$}}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Determines minimum timestep for simulation, average time between outgassing/desorption and adsorption
%\item $T_{min}$ computed in \codew{Iteration.cpp} file in \codew{estimateAverageFlightTime()} using simulationHistory: $\text{flightTime}/\text{nParticles}$ 
%\end{itemize}
%
%\subsubsection{Management of time step \codew{$T_{min}$}}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Currently not used
%\item Chooses larger value between \codew{estimateAverageFlightTime()} and \codew{getStepSize()}
%\item Checks whether current time step would cause covering to get negative
%\item Adapts time step if needed
%\item Increments \codew{SimulationHistory::currentStep} if \codew{getStepSize()} chosen and not decreased
%\item Management in \codew{UpdateMainProcess.cpp} file in \codew{manageTimeStep($\cdot$)}
%\end{itemize}
%
%\subsubsection{Management of Simulation Time}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Increases simulation time (=computation time) per iteration if not enough particles desorbed
%\item Adapts simulation time if needed
%\item If enough desorption: compute maximum ratio $step size/computation time$
%\item If not enough desorption: adapt computation time using ration $step size/computation time$
%\item Management in \codew{UpdateMainProcess.cpp} file in \codew{manageSimulationTime($\cdot$)}
%\end{itemize}
