% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{ContaminationFlow Linux}\label{chapter:Linux}
%\AddToShipoutPicture*{\ShowFramePicture}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Parallel simulation on several sub processes
\item Processing and control of data in main process
\item Update and accumulation of hit counters and other information such as profiles
\item \codew{SimulationHistory}, final \codew{hitbuffer} and used parameters exported to results folder
\end{itemize}
\smallskip
\begin{figure}[hb]
\centering
\begin{tikzpicture}[node distance=2cm, font=\footnotesize]
%\draw [help lines] (0,0) grid (4,4);
	\node (p0buffer)[textboxmed, rectangle split, rectangle split parts=2] at (0,9.8)
	{
		\textbf{Main Process 0}
		\nodepart{second} loadbuffer, hitbuffer
	};

	\node (p0loadbuffer)[textboxmed, rectangle split, rectangle split parts=2] at (0,8)
	{
		\textbf{Main Process 0}
		\nodepart{second} Broadcast loadbuffer
	};

	\node (p0hitbuffer)[textboxmed, rectangle split, rectangle split parts=2] at (0,5.7)
	{
		\textbf{Main Process 0}
		\nodepart{second} Broadcast hitbuffer
	};

	\node (p1geo)[textboxmed, rectangle split, rectangle split parts=2] at (5,6.5)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Load geometry
	};

	\node (p1upd)[textboxmed, rectangle split, rectangle split parts=2] at (5,4.5)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Update Quantities from hitbuffer
	};

	\node (p1sim)[textboxmed, rectangle split, rectangle split parts=2] at (5,2.4)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Simulation
	};

	\node (p1hit)[textboxmed, rectangle split, rectangle split parts=2] at (5,0.7)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Save information in hitbuffer\_1
	};

	\node (p0p1hit)[textboxmed, rectangle split, rectangle split parts=2] at (0,0.7)
	{
		\textbf{Main Process 0}
		\nodepart{second} hitbuffer +=\\ hitbuffer\_1
	};


	\node (pNgeo)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,6.5)
	{
		\textbf{Sub Process K}
		\nodepart{second} Load geometry
	};

	\node (pNupd)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,4.5)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Update Quantities from hitbuffer
	};

	\node (pNsim)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,2.4)
	{
		\textbf{Sub Process K}
		\nodepart{second} Simulation
	};

	\node (pNhit)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,0.7)
	{
		\textbf{Sub Process K}
		\nodepart{second} Save information in hitbuffer\_N-1
	};

	\node (p0pNhit)[textboxmed, rectangle split, rectangle split parts=2] at (0,-2.5)
	{
		\textbf{Main Process 0}
		\nodepart{second} hitbuffer += hitbuffer\_N-1
	};

	\node (p0upd)[textboxmed, rectangle split, rectangle split parts=2] at (0,-4.7)
	{
		\textbf{Main Process 0}
		\nodepart{second} Update real covering in hitbuffer
	};

	\draw let \p1=(p0buffer.second west) in [->, line width=0.04cm] (\x1-1.5cm,\y1) -- (\p1);
	\path let \p1=(p0buffer.second west) in node [above] at (\x1-0.75cm,\y1) {Import};

	\draw[->, line width=0.04cm] (p0buffer.south)--(p0loadbuffer.north);

	%\draw[->, line width=0.04cm] (1.9,7) -- (11.5,7)--(11.5,6.6);
	\draw let \p1=(p0loadbuffer.second east), \p2=(pNgeo.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	%\draw[->, line width=0.04cm] (5,7)--(5,6.6);
	\draw let \p1=(p0loadbuffer.second east), \p2=(p1geo.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	\draw[fill] let \p1=(p0loadbuffer.second east), \p2=(p1geo.north) in (\x2,\y1) circle [radius=0.05];
	\path let \p1=(p0loadbuffer.second east), \p2=(p1geo.west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	\draw let \p1=(p0hitbuffer.second east), \p2=(pNupd.north) in [->, line width=0.04cm] (\p1) -- (\x2-0.5cm,\y1)-- (\x2-0.5cm,\y2);
	\draw let \p1=(p0hitbuffer.second east), \p2=(p1upd.north) in [->, line width=0.04cm] (\p1) -- (\x2-0.5cm,\y1)-- (\x2-0.5cm,\y2);
	\draw[fill] let \p1=(p0hitbuffer.second east), \p2=(p1upd.north) in (\x2-0.5cm,\y1) circle [radius=0.05];
	\path let \p1=(p0hitbuffer.second east), \p2=(p1upd.west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	%\draw[fill] (8,6) circle [radius=0.06];
	%\draw[fill] (8.25,6) circle [radius=0.06];
	%\draw[fill] (8.5,6) circle [radius=0.06];
	\foreach \i in{-1,0,1}
		\draw[fill] let \p1=(p1geo.east), \p2=(pNgeo.west) in (0.5*\x1+0.5*\x2+0.25cm*\i,\y1) circle [radius=0.06];

	%\draw[->, line width=0.04cm] (11.5,5.3)--(11.5,4.86);
	\draw[->, line width=0.04cm] (pNgeo.south)--(pNupd.north);
	\draw[->, line width=0.04cm] (pNupd.south)--(pNsim.north);
	%\draw[->, line width=0.04cm] (5,5.3)--(5,4.86);
	\draw[->, line width=0.04cm] (p1geo.south)--(p1upd.north);
	\draw[->, line width=0.04cm] (p1upd.south)--(p1sim.north);
	%\draw[->, line width=0.04cm] (11.5,3.66)--(11.5,3.3);
	\draw[->, line width=0.04cm] (pNsim.south)--(pNhit.north);
	%\draw[->, line width=0.04cm] (5,3.66)--(5,3.3);
	\draw[->, line width=0.04cm] (p1sim.south)--(p1hit.north);

	%\draw[->, line width=0.04cm] (0,6.7)--(0,3.3);
	\draw[->, line width=0.04cm] (p0loadbuffer.south)--(p0hitbuffer.north);
	\draw[->, line width=0.04cm] (p0hitbuffer.south)--(p0p1hit.north);
	%\draw[<-, line width=0.04cm] (1.9,-1.1) -- (11.5,-1.1)--(11.5,1.53);
	\draw let \p1=(p0pNhit.second east), \p2=(pNhit.south) in [<-, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	%\draw[<-, line width=0.04cm] (1.9,2.3) -- (3.1,2.3);
	\draw[<-, line width=0.04cm] (p0p1hit.second east)--(p1hit.second west);
	

	\path let \p1=(p0pNhit.second east), \p2=(p1hit.second west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};
	\path let \p1=(p0p1hit.second east), \p2=(p1hit.second west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	\draw let \p1=(p0upd.second west) in [<-, line width=0.04cm] (\x1-1.5cm,\y1-0.2cm) -- (\x1,\y1-0.2cm);
	\path let \p1=(p0upd.second west) in node [below] at (\x1-0.75cm,\y1-0.2cm) {Export};

	%\draw[fill] (0,0.66) circle [radius=0.06];
	%\draw[fill] (0,0.41) circle [radius=0.06];
	%\draw[fill] (0,0.91) circle [radius=0.06];
	\foreach \i in{-1,0,1}
		\draw[fill] let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in (\x1,0.5*\y1+0.5*\y2+0.25cm*\i) circle [radius=0.06];

	%\draw[->, line width=0.04cm] (0,1.53)--(0,1.10);
	\draw let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in [->, line width=0.04cm] (\p1)--(\x1, 0.5*\y1+0.5*\y2+0.5cm);
	%\draw[->, line width=0.04cm] (0,0.2)--(0,-0.2);
	\draw let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in [<-, line width=0.04cm] (\p2)--(\x1, 0.5*\y1+0.5*\y2-0.5cm);

	\draw let \p1=(p0pNhit.south), \p2=(p0upd.north) in [->, line width=0.04cm] (\p1)--(\p2);
	\draw let \p1=(p0upd.second west), \p2=(p0hitbuffer.second west) in [->, line width=0.04cm] (\x1,\y1+0.2cm)--(\x1-1.5cm, \y1+0.2cm) -- (\x1-1.5cm,\y2) --(\p2);	
\end{tikzpicture}
\caption{Processing of data in main and sub processes}
\end{figure}


\section{Call of Application from Command line}

\subsubsection{New class ProblemDef}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Defines parameters used for simulation
\item Possible adaptation of default paramaters through input file
%\item Conducts some intern conversions
\item Creates result folder for simulation if desired
	\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
	\item Final resultbuffer
	\item Final covering, input file and console output as text files
	\end{itemize}
\end{itemize}
%\bigskip

\subsubsection{Application with custom parameters using input file}
Call of ContaminationFlow Linux application in the command line:
\code{
\$ module load mpi\\
\$ mpirun -n N\ MolflowLinux inputfile save}
\smallskip
with the following command line parameters:
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item \codew{N}: desired number of worker processes; simulation on K=N-1 worker processes
\item \codew{MolflowLinux}: path to application, e.g.\ \codew{\textasciitilde/MolflowLinux/Debug/MolflowLinux}
\item \codew{inputfile}: path to file that defines simulation parameters
\item \codew{save}: determines whether result directory is created (1: true, 0:false); default:\codew{1}
\end{itemize}
\smallskip
\smallskip
and the input file defining the following parameters:
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item \codew{$loadbufferPath$}: path to loadbuffer file, contains geometry, e.g.\ \codew{\textasciitilde/loadbuffer}
\item \codew{$hitbufferPath$}: path to hitbuffer file, contains counters, etc., e.g.\ \codew{\textasciitilde/hitbuffer}
%\item resultbufferPath: path to resultbuffer file, where the final hitbuffer is exported to,\\ e.g.\ \codew{\textasciitilde/resultbuffer}
\item \codew{$simulationTime$}: simulation time per iteration step; default: \codew{10.0}
\item \codew{$unit$}: simulation time unit; default: \codew{s}
\item \codew{$maxTime$}: maximum simulation time; default: \codew{10.0}
\item \codew{$maxUnit$}: maximum simulation time unit; default: \codew{y}
\item \codew{$iterationNumber$}: number of iterations; default: 43200
%\item \codew{$s_1$}, coefficient used for calculation of sticking coefficient; default:\codew{1}
%\item \codew{$s_2$}, coefficient used for calculation of sticking coefficient; default:\codew{0.2}
%\item \codew{$E_{ad}$}, energy used for calculation of sticking coefficient; default:\codew{1\text{E}-21}
%\item\codew{$d$}: power for base of coverage used for calculation of desorption; default:\codew{1}
\item \codew{$particleDia$}: diameter of particles; default:\codew{2$ \cdot $76\text{E}-12}
\item \codew{$E_{de}$}: binding energy of a particle on pure substrate; default:\codew{1\text{E}-21}
\item \codew{$H_{vap}$}: vaporization enthalpy of a particle in case of multilayer contamination; default:\codew{0.8\text{E}-19}
\item \codew{$W_{tr}$}: transition width between monolayer and multilayer properties; default:\codew{1}
\item \codew{$sticking$}: constant sticking coefficient for all facets, set to zero, not used at the moment; default:\codew{0}
%\item \codew{$coveringLimit$}: threshold for zero desoprtion; default:\codew{0}
\item \codew{$targetPaticles$}: minimum number of desorbed particles per iter.; default: \codew{1000}
\item \codew{$targetError$}: average statistical uncertainty (error) to be achieved for each iteration, calculated as the average (weighted with the facets area) of the normalized standard deviation of events per facet; default: \codew{0.001}
\item \codew{$hitRatioLimit$}: Ratio at which hits are ignored, default: \codew{0}
\item \codew{$Tmin$} or \codew{$t\_min$}: minimum time for step size; default:\codew{1\text{E}-4}
\item \codew{$maxStepSize$} or \codew{$t\_max$}: maximum time for step size; default:\codew{max}
\item \codew{$maxSimPerIt$}: maximum simulation steps per iteration; default:\codew{max}
\item \codew{$coveringMinThresh$}: minimum covering (through multiplication); default:\codew{10000}
\item \codew{$histsize$}: Size of history lists; default:\codew{max}
\item \codew{$vipFacets$}: very important facets: facets with have their own target error. input in inputfile as alternating sequence of facet numbers and respective target errors seperated via blanks; default:\codew{[]}
\end{itemize}
%\section{General Changes}
%
%\subsubsection{Replacement/removal of Windows libraries/functions}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Databuff struct with import/export instead of using Dataports
%\item Replacements of libraries, e.g.\ \codew{\#include <time.h>} with \codew{\#include <sys/time.h>}
%\end{itemize}
%
%\subsubsection{Removal of functions used in \codew{AC\_MODE}}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Only \codew{MC\_MODE} used
%\item Removal of \codew{AC\_MODE} cases and functions
%\end{itemize}

\subsubsection{Terminology}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Simulation time: desired computation time until check if target is reached for iteration
\item Simulated time: physical time in the simulated system, e.g.\ flight time or residence time of a particle
\item Maximum simulation time: desired total simulated time
\item Step size: desired simulated time per particle for iteration
\end{itemize}

\section{Communication}
\subsubsection{Import and export of buffer files}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item New Databuff struct that replaces Dataport struct from MolFlow Windows \code{typedef unsigned char BYTE;\\typedef struct \{\\
	\hphantom{\quad}signed int size;\\
	\hphantom{\quad}BYTE *buff;\\
\} Databuff;}
\item New functions \codew{importBuff($\cdot$)} and \codew{exportBuff($\cdot$)} for import of buffer files and export of Databuff struct
\item New functions \codew{checkReadable($\cdot$)} and \codew{checkWriteable($\cdot$)} to check if file is readable or writeable
\end{itemize}

\subsubsection{Communication between worker processes via MPI}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Main process 0 sends Databuff struct containing loadbuffer and Databuff struct containing hitbuffer and required simulationHistory values to sub processes using \codew{MPI\_Bcast($\cdot$)}
\item Sub processes send updated Databuff struct containing hitbuffer and required simulationHistory values to main process 0 using \codew{MPI\_Send($\cdot$)} and \codew{MPI\_Recv($\cdot$)}
\end{itemize}

\section{Usage of $boost$ Library}
\subsubsection{Multiprecision}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Increase precision for variables if required
\item Avoid overflow for integer and underflow for floating point numbers
\end{itemize}
%\newpage
\section{New Quantities}
\label{sub:quant}
\subsubsection{New counter \codew{covering}}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of carbon equivalent particles on facet
\item Increases with adsorption, decreases with desorption
\item Extracted from new hitbuffer counter from \codew{Simulationcalc.cpp} file in \codew{getCovering($\cdot$)}
\end{itemize}

\subsubsection{Coverage}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of monolayers of adsorbed particles
\item Calculated from covering, particle diamieter (previously gas mass) and facet area
\item Coverage computed from \codew{Simulationcalc.cpp} file in \codew{calcCoverage($\cdot$)}
\end{itemize}

\subsubsection{Sticking factor}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Ratio adsorbed particles to impinging particles
\item Set to 0, can be adapted for all facets through input file
\end{itemize}

\subsubsection{Binding energy}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Either  \codew{$E_{de}$} or \codew{$H_{vap}$}
\item TODO: depending on ??
%\item Calculated from \codew{$E_{de}$}, \codew{$H_{vap}$} and \codew{$W_{tr}$}
%\item Energy computed from \codew{Simulationcalc.cpp} file in \codew{calcEnergy($\cdot$)}
\end{itemize}

\subsubsection{Desorption}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of particles desorbing
\item Calculated from binding energy, covering and temperature
\item Desorption computed from \codew{Simulationcalc.cpp} file in \codew{calcDesorption($\cdot$)}
\end{itemize}

%\subsubsection{Desorption Rate $[\text{Pa m}^3/\text{s}]$}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Calculated from desorption, gas mass and facet area before each iteration
%\item Used to determine starting point for new particle
%\item Desorption rate computed from \codew{Simulationcalc.cpp} file in \codew{calcDesorptionRate($\cdot$)}
%\end{itemize}

\subsubsection{Outgassing}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of particles from outgassing
\item Calculated from facet outgassing and temerature defined in sHandle
\item Outgassing computed from \codew{Worker.cpp} file in \codew{CalcTotalOutgassingWorker()}
\end{itemize}

\subsubsection{$\text{K}_{\text{real}/\text{virtual}}$}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of real particles represented by test particles
\item Calculated from desorption \& outgassing and number of desorbed molecules
\item $\text{K}_{\text{real}/\text{virtual}}$ computed from \codew{Simulationcalc.cpp} file in \codew{GetMoleculesPerTP($\cdot$)}
\end{itemize}

\subsubsection{Statistical Error}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Event error: calculated from hits and desorbed particles (of facet and total)
\item Covering error: calculated from adsorbed and desorbed particles (of facet and total)
\item Used to determine significance of simulation results of iteration
\end{itemize}

\subsubsection{Step size}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Minimum time between adsorption and desorption
\item Step size computed from \codew{UpdateMainProcess.cpp} file in \codew{getStepSize()} 
\end{itemize}
\newpage
\section{Iterative Algorithm}

\subsection{Initialization of simulation}
\begin{figure}[!htb]
\centering
\begin{tikzpicture}[node distance=2cm, font=\footnotesize]
	\tikzstyle{condition} = [diamond, draw, minimum width= 4cm, align=center,  aspect=1.5]
	\tikzstyle{module} = [ellipse,draw, minimum width= 4cm, align=center, aspect=1.5]
	\tikzstyle{neuron}= [rectangle,draw, minimum width= 4cm, align=center, aspect=1.5]

	\node[module](start)  at (0,0) {Start\\Initialization};
	\node[neuron](input) at (0,-2) {Load parameters\\from input file};
	\draw let \p1=(start.south), \p2=(input.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](load) at (6,-2) {Main process:\\Import loadbuffer\\and broadcast};
	\draw let \p1=(input.east), \p2=(load.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](geom) at (12,-2) {Load geometry \&\\init simHistory};
	\draw let \p1=(load.east), \p2=(geom.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[module](end)  at (12,0) {End\\Initialization};
	\draw let \p1=(geom.north), \p2=(end.south) in [->, line width=0.04cm] (\p1) -- (\p2);

\end{tikzpicture}
\caption{Overview: Initialize simulation}
\end{figure}

\subsubsection{New class to store Simulation History}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item SimulationHistory class \code{class SimulationHistory \{\\
	public:\\
	\hphantom{\enskip}SimulationHistory();\\
	\hphantom{\enskip}SimulationHistory(Databuff *hitbuffer);\\
	\\
	\hphantom{\enskip}HistoryList<llong> coveringList;\\
	\hphantom{\enskip}HistoryList<llong> desorbedList;\\
	\hphantom{\enskip}HistoryList<double> hitList;\\
	\hphantom{\enskip}HistoryList<double> errorList\_event;\\
	\hphantom{\enskip}HistoryList<double> errorList\_covering;\\
	\\
	\hphantom{\enskip}double lastTime;\\
	\hphantom{\enskip}int currentStep;\\
\};}
\code{template <typename T> class HistoryList \{\\
	public:\\
	\hphantom{\enskip}HistoryList();\\
	\hphantom{\enskip}std::vector<std::pair<double,std::vector<T>\,>\,> pointInTimeList;\\
	\hphantom{\enskip}std::vector<T> currentList;\\
\};}
\item In \codew{SimulationLinux.h} and \codew{SimulationLinux.cpp} file
\item SimulationHistory updated after each iteration in \codew{UpdateCovering($\cdot$)} from\linebreak[4] \codew{UpdateMainProcess.cpp} file
\item Currently recorded quantities: covering and error (event and covering) for each facet for each iteration, total hits and desorbed particles for each facet
\item lastTime: simulated time (accumulated time steps) instead of computation time 
\end{itemize}

 \subsection{Simulation on subprocesses}
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance=2cm, font=\footnotesize]
	\tikzstyle{condition} = [diamond, draw, minimum width= 4cm, align=center,  aspect=1.5]
	\tikzstyle{module} = [ellipse,draw, minimum width= 4cm, align=center, aspect=1.5]
	\tikzstyle{neuron}= [rectangle,draw, minimum width= 4cm, align=center, aspect=1.5]

	\node[module](start)  at (0,-0.2) {Start simulation\\sub process};
	\node[neuron](preprocess) at (6,-0.2) {Calculate desorption,\\sojourn variables,\\cov. thresh. \& step size;\\multiply cov. if small};
	\draw let \p1=(start.east), \p2=(preprocess.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](nbSteps) at (1,-1.9) {Calculate steps for \\desired simulation time};
	\draw let \p1=(preprocess.south), \p2=(nbSteps.east) in [->, line width=0.04cm] (\p1) --  (\x1,\y2)-- (\p2);

	\node[condition, aspect=1.5](exist) at (1,-3.8){Particle\\exists?};
	\draw let \p1=(nbSteps.south), \p2=(exist.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](particle) at (1,-5.8) {Create particle\\Add sojourn time};
	\draw let \p1=(exist.south), \p2=(particle.north) in [->, line width=0.04cm] (\p1) -- (\p2)node[midway, right]{false};

	\node[condition, aspect=1.5](time3) at (6,-5.8){flight time$>$\\step size?};
	\draw let \p1=(particle.east), \p2=(time3.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[condition, aspect=1.5](covthresh) at (11,-5.8){Cov. thresh.\\reached?};
	\draw let \p1=(time3.east), \p2=(covthresh.west) in [->, line width=0.04cm] (\p1) -- (\p2)node[midway, above]{false};
	\draw let \p1=(exist.east), \p2=(covthresh.north) in [->, line width=0.04cm] (\p1) --(\x1+1cm,\y1)node[midway, above]{true}--(\x2,\y1)-- (\p2);

	\node[neuron](facet) at (6,-7.9) {Find next facet};
	\draw let \p1=(covthresh.south), \p2=(facet.east) in [->, line width=0.04cm] (\p1) -- (\x1,\y2) node[midway, right]{false} --(\p2);

	\node[condition, aspect=1.5](time1) at (1,-9.7){flight time$>$\\step size?};
	\draw let \p1=(facet.west), \p2=(time1.north) in [->, line width=0.04cm] (\p1) --  (\x2,\y1)--(\p2);

	\node[neuron](sojourn) at (6,-9.7) {Add sojourn time};
	\draw let \p1=(time1.east), \p2=(sojourn.west) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, above]{false};

	\node[condition, aspect=1.5](time2) at (6,-12.0){flight time$>$\\step size?};
	\draw let \p1=(sojourn.south), \p2=(time2.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](hit) at (6,-14.3) {Record hit};
	\draw let \p1=(time2.south), \p2=(hit.north) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, right]{false};
	\draw let \p1=(hit.east), \p2=(facet.east) in [ line width=0.04cm] (\p1) -- (11,\y1) -- (11,\y2) ;

	\node[neuron](absorb) at (1,-12.0) {Record absorb};
	\draw let \p1=(time1.south), \p2=(absorb.north) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, right]{true};
	\draw let \p1=(time2.west), \p2=(absorb.east) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, above]{true};
	\draw let \p1=(time3.south),\p2=(absorb.west) in [->, line width=0.04cm](\p1) --(\x1,\y1-0.2cm) --node[midway, above]{true}(\x1-1.5cm,\y1-0.2cm)--(\x2-0.33cm,\y1-0.2cm)--(\x2-0.33cm,\y2)--(\p2);

	\node[condition, aspect=1.5](steps) at (1,-14.3){No.steps\\reached?};
	\draw let \p1=(absorb.south), \p2=(steps.north) in [->, line width=0.04cm] (\p1) -- (\p2);
	\draw let \p1=(steps.west), \p2=(particle.west) in [->, line width=0.04cm] (\p1) --(\x1-0.66cm,\y1)-- node[midway, right]{false}(\x1-0.66cm,\y1+1cm)-- (\x1-0.66cm,\y2) -- (\p2);

	%\node[condition, aspect=1.5](steps2) at (11,-14.3){No.steps\\reached?};
	%\draw let \p1=(hit.east), \p2=(steps2.west) in [->, line width=0.04cm] (\p1) -- (\p2);
	%\draw let \p1=(steps2.north), \p2=(facet.east) in [ line width=0.04cm] (\p1) --node[midway, right]{false}(\x1,\y1+1cm)-- (\x1,\y2) -- (6, \y2);

	\node[condition, aspect=1.5](target) at (6,-17.2){Target error\\reached?};
	\draw let \p1=(steps.south), \p2=(target.north) in [->, line width=0.04cm] (\p1) --(\x1,\y1-0.3cm) --node[midway, above]{true}(\x1+2cm,\y1-0.3cm)--(\x2,\y1-0.3cm)-- (\p2);
	%\draw let \p1=(steps2.south), \p2=(target.north) in [ line width=0.04cm] (\p1) --(\x1,\y1-0.3cm) --node[midway, above]{true}(\x1-2cm,\y1-0.3cm)--(\x2,\y1-0.3cm);
	\draw let \p1=(target.west), \p2=(nbSteps.west) in [->, line width=0.04cm] (\p1) --node[midway, above]{false}(\x1-1cm, \y1)--(\x1-6cm,\y1)-- (\x1-6cm,\y2) -- (\p2);

	\node[neuron](hitbuffer) at (11,-1.9) {Update hitbuffer};
	\draw let \p1=(target.east), \p2=(hitbuffer.east) in [->, line width=0.04cm] (\p1) -- (\x1+1cm,\y1) node[midway, above]{true}--(\x1+6cm,\y1)--(\x1+6cm,\y2) -- (\p2);
	\draw let \p1=(covthresh.east) in [ line width=0.04cm] (\p1) -- (\x1+1cm,\y1) node[midway, above]{true};

	\node[module](end)  at (12,-0.2) {End simulation\\sub process};
	\draw let \p1=(hitbuffer.north), \p2=(end.south) in [->, line width=0.04cm] (\x2,\y1) -- (\p2);

\end{tikzpicture}
\caption{Overview: simulation on sub processes}
\end{figure}

\subsubsection{Calculate Step Size}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Use \codew{simHistory$\rightarrow$currentStep} to calculate logarithmic step size
\item Calculation in \codew{UpdateMainProcess.cpp} file in \codew{getStepSize()}
\end{itemize}

\subsubsection{Calculate Covering Threshold}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Set lower threshold for covering for each facet to prevent covering getting negative
\item Stop simulation once threshold is reached
\item Threshold set in \codew{setCoveringThreshold($\cdot$)}  from \codew{Iteration.cpp} file
\end{itemize}

\subsubsection{Multiply small covering}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Multiply covering so that smallest covering $\geq$ \codew{ProblemDef::coveringThreshMin}
\item Multiply covering threshold with same factor
\item Calculation in \codew{checkSmallCovering($\cdot$)} from \codew{SimulationLinux.cpp} file
\end{itemize}

\subsubsection{Calculate desorption}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Desorption calculated from current covering values
\item Calculation in \codew{UpdateDesorption($\cdot$)}  from \codew{UpdateSubProcess.cpp} file
\end{itemize}

\subsubsection{Calculate residence time and binding energy}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Residence time of a particle on a surface calculated from binding energy, coverage and thermal oscillation frequency
\item Binding energy calculated using binding energy on pure substrate, vaporization enthalpy and coverage
\item Thermal oscillation frequency calculated using temperature, Boltzmann constant and Planck's constant
\item Calculation in \codew{UpdateSojourn($\cdot$)}  from \codew{UpdateSubProcess.cpp} file
\end{itemize}

\subsubsection{Target error reached?}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculate statistical error in \codew{UpdateError()} from \codew{UpdateSubProcess.cpp} file
\item Error to check can be either covering or event error (currently covering)
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Check if vip facets reached their own target error
\item Check if normal facets total error reached target error
\item Currently vip facets not included in normal facets
\end{itemize}
\item Total error calculated from summing facet error weighted with facet area
\item Set error of facets that reached \codew{ProblemDef::hitRatioLimit} to $inf$
\item Set error of facets with no hits and desorption to $inf$
\item Facets with error=$inf$ are not considered
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item if vip facet: target automatically reached
\item if normal facet: facet error and area not used for calculation
\end{itemize}
\item Check in \codew{checkErrorSub($\cdot$)} from \codew{UpdateSubProcess.cpp} file
\end{itemize}

\section{Update main buffer}
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance=2cm, font=\footnotesize]
	\tikzstyle{condition} = [diamond, draw, minimum width= 4cm, align=center,  aspect=1.5]
	\tikzstyle{module} = [ellipse,draw, minimum width= 4cm, align=center, aspect=1.5]
	\tikzstyle{neuron}= [rectangle,draw, minimum width= 4cm, align=center, aspect=1.5]

	\node[module](start)  at (0,-0.5) {Start update\\main process};

	%\node[neuron](small) at (0,-2.2) {Divide cov. if\\previously multiplied};
	%\draw let \p1=(start.south), \p2=(small.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](K) at (0,-2.9) {Calculate $K_{real/virt}$};
	\draw let \p1=(start.south), \p2=(K.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](error) at (0,-5) {Calculate error of\\current iteration};
	\draw let \p1=(K.south), \p2=(error.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	%\node[neuron](stepsize) at (0,-5) {Calculate step size\\from $currentStep$};
	%\draw let \p1=(error.south), \p2=(stepsize.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	%\node[condition](decrease) at (5,-5) {Step size\\decreased?};
	%\draw let \p1=(stepsize.east), \p2=(decrease.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[condition](target) at (4.8,-5) {Target error\\reached?};
	\draw let \p1=(error.east), \p2=(target.west) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, above] {false};

	\node[neuron, minimum width=3cm](increase) at (9.2,-5) {Increase\\$currentStep$};
	%\draw let \p1=(target.east), \p2=(increase.south) in [->, line width=0.04cm] (\p1) -- (\x2+0.5cm, \y1) node[midway, above] {true}--([xshift=0.5cm]\p2);
	\draw let \p1=(target.east), \p2=(increase.west) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, above] {true};

	\node[neuron, minimum width=5cm](cov) at (7,-2.9) {Calculate real covering};
	%\draw let \p1=(decrease.north), \p2=(update.south) in [->, line width=0.04cm] (\p1) -- (\x1,\y2) node[midway, right] {true};
	\draw let \p1=(target.north), \p2=(cov.south) in [->, line width=0.04cm] (\p1) -- (\x1,\y2) node[midway, right] {false};
	\draw let \p1=(increase.north), \p2=(cov.south) in [->, line width=0.04cm] (\p1) -- (\x1,\y2);

	\node[neuron, minimum width=5cm](update) at (7,-1.5) {Update covering to\\ hitbuffer and simHistory};
	\draw let \p1=(cov.north), \p2=(update.south) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[module](end)  at (12,-0.5) {End update\\main process};
	\draw let \p1=(update.north), \p2=(end.west) in [->, line width=0.04cm] (\p1) -- (\x1,\y2) --(\p2);
\end{tikzpicture}
\caption{Overview: update of covering in hitbuffer}
\end{figure}

\subsubsection{Before summation of subprocesses}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculate step size iin \codew{UpdateMainProcess.cpp} file in \codew{getStepSize()}
\item Multiply covering in \codew{hitbuffer} of main process  in \codew{checkSmallCovering($\cdot$)} from \codew{SimulationLinux.cpp} file if covering is multiplied in sub processes
\end{itemize}

%\subsubsection{Divide small covering after  summation of subprocesses}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Division by the small covering factor will be done when converting virtual test particles into real, physical particles
%\item Then, \codew{hitbuffer} and \codew{hitbuffer\textunderscore sum} of main process will be overwritten with the real, physical values anyway. So there is no need to divide by the small covering factor.
%\end{itemize}

\subsubsection{Error Calculation}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculate statistical error of normal facets
\item Error to can be either covering or event error (currently covering)
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Covering: adsorbed and desorbed particles, weighted with opacity
\item Events: hits and desorbed particles, weighted with opacity
\end{itemize}
\item Total error calculated from summing facet error weighted with facet area
\item Set error of facets that reached \codew{ProblemDef::hitRatioLimit} to $inf$
\item Set error of facets with no hits and desorption to $inf$
\item Facets with error=$inf$ are not used for calculation of total error
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item if vip facet: target automatically reached
\item if normal facet: facet error and area not used for calculation
\end{itemize}
\item Save error in \codew{simHistory$\rightarrow$errorList}
\item Management in \codew{UpdateErrorMain($\cdot$)} from \codew{UpdateMainProcess.cpp} file
\item[]$\Rightarrow$ Increase \codew{simHistory$\rightarrow$currentStep} if target error reached
\end{itemize}

%\subsubsection{Management of Step Size}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Adapt step size if desorption $\times$ time step was larger than covering 
%\item Increase \codew{simHistory$\rightarrow$currentStep} if no adaptation \& target errors reached
%\item Management in \codew{manageStepSize($\cdot$)} from \codew{UpdateMainProcess.cpp} file
%\end{itemize}

\subsubsection{Calculate \& Update Covering}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item $\text{K}_{\text{real}/\text{virtual}}$ computed from \codew{Simulationcalc.cpp} file in \codew{GetMoleculesPerTP($\cdot$)}
\item Divide covering in \codew{hitbuffer}  if previously multiplied
\item Use $K_{real/virt}$ to calculate new covering
\item Save new covering in \codew{simHistory$\rightarrow$coveringList} and hitbuffer
\item Calculation in \codew{UpdateCovering($\cdot$)} from \codew{UpdateMainProcess.cpp} file
\item Update buffers in \codew{UpdateCoveringPhys($\cdot$)} from \codew{UpdateMainProcess.cpp} file
\end{itemize}
\newpage
\section{Summary}
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance=2cm, font=\footnotesize]
	\tikzstyle{condition} = [diamond, draw, minimum width= 4cm, align=center,  aspect=1.5]
	\tikzstyle{module} = [ellipse,draw, minimum width= 4cm, align=center, aspect=1.5]
	\tikzstyle{neuron}= [rectangle,draw, minimum width= 4cm, align=center, aspect=1.5]

	\node[module](start)  at (0,0.1) {Start\\Application};
	\node[neuron](smpi) at (0,-1.6) {Initialize MPI};
	\draw let \p1=(start.south), \p2=(smpi.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[module](preprocess) at (0,-2.9) {Initialization};
	\draw let \p1=(smpi.south), \p2=(preprocess.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](bcast) at (0,-4.8) {Main process:\\broadcast\\ simHistory$\rightarrow$coveringList\\ and $currentStep$};
	\draw let \p1=(preprocess.south), \p2=(bcast.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\path let \p1=(bcast.east) in node[module](sim1) at (4.5,\y1+1.2cm) {Simulation\\sub process};
	\draw let \p1=(bcast.east), \p2=(sim1.west) in [->, line width=0.04cm] (\x1, \y1+0.4cm) -- (\p2);

	\path let \p1=(bcast.east) in node[module](sim2) at (4.5,\y1-1.2cm) {Simulation\\sub process};
	\draw let \p1=(bcast.east), \p2=(sim2.west) in [->, line width=0.04cm] (\x1, \y1-0.4cm) -- (\p2);

	\foreach \i in{-1,0,1}
		\draw[fill] let \p1=(sim1.south), \p2=(sim2.north) in (\x1,0.5*\y1+0.5*\y2+0.25cm*\i) circle [radius=0.06];

	\node[neuron, rotate=90, minimum height=1.4cm](sum) at (7.8,-4.8){Summarize results\\in main hitbuffer};
	\draw let \p1=(sim1.east), \p2=(sum.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1);
	\draw let \p1=(sim2.east), \p2=(sum.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1);

	\node[module](update) at (11,-6) {Update\\main process};
	\draw let \p1=(sum.south), \p2=(update.west) in [->, line width=0.04cm] (\x1,\y2) -- (\p2);

	\node[condition](max) at (11, -3.6) {Max. time\\reached?};
	\draw let \p1=(update.north), \p2=(max.south) in [->, line width=0.04cm] (\p1) -- (\p2);
	\draw let \p1=(max.east), \p2=(bcast.south) in [->, line width=0.04cm] (\p1) --(\x1+1cm, \y1) node[midway,above]{false} --(\x1+1cm, \y2-1.5cm) --(\x2, \y2-1.5cm)-- (\p2);

	\node[neuron](save) at (11,-1.6) {Save results};
	\draw let \p1=(max.north), \p2=(save.south) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway,right]{true};

	\node[neuron](empi) at (5.5,-1.6) {Finalize MPI};
	\draw let \p1=(save.west), \p2=(empi.east) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[module](end)  at (12,0.1) {End\\Application};
	\draw let \p1=(empi.north), \p2=(end.west) in [->, line width=0.04cm] (\p1)-- (\x1,\y2) -- (\p2);
	
\end{tikzpicture}
\caption{Overview: ContaminationFlow application}
\end{figure}

\subsubsection{General Pipeline}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Initialize MPI, \codew{ProblemDef p} and \codew{SimulationHistory simHistory}
\item Load geometry into \codew{Simulation sHandle} using \codew{LoadSimulation()}
\item Iteration until desired maximum simulation time is reached: \smallskip
	\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
	\item[$\bullet$] Reset hitbuffer counters using \codew{initbufftotero($\cdot$)}
	\item[$\bullet$] Broadcast \codew{simHistory$\rightarrow$coveringList} using \codew{MPI\_Bcast($\cdot$)}
	\item[$\bullet$] Simulation in sub processes
	\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
	\item[--] Simulate until \codew{targetParticles} and \codew{targetError} or \codew{covthresh} reached
	\item[--] Update hitbuffers of sub processes from \codew{sHandle} using \codew{UpdateSubHits($\cdot$)} from \codew{UpdateSubProcess.cpp}
	\end{itemize}
	\item[$\bullet$] Update Main process:
		\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
		\item[--] Send hitbuffer to main process using \codew{MPI\_Send($\cdot$)} and \codew{MPI\_Recv($\cdot$)}
		\item[--] Update of hitbuffer in \codew{UpdateMainHits($\cdot$)} from \codew{UpdateMainProcess.cpp}
		\end{itemize}
	\item[$\bullet$] Update error of iteration using \codew{UpdateErrorMain($\cdot$)} from \codew{UpdateMainProcess.cpp}
	\item[$\bullet$] Calculate real covering in main process using $\text{K}_{\text{real}/\text{virtual}}$ in \codew{UpdateCovering($\cdot$)} from \codew{UpdateMainProcess.cpp}, save in \codew{simHistory}
	\item[$\bullet$] Update real covering in hitbuffer of main process in \codew{UpdateCoveringphys($\cdot$)} from \codew{UpdateMainProcess.cpp}
	\end{itemize}\smallskip
\item Export final results (hitbuffer and simulationHistory) to results folder
\item Close MPI
\end{itemize}
\newpage




%\subsubsection{Thats changed}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item use this for 
%\item list
%\end{itemize}


