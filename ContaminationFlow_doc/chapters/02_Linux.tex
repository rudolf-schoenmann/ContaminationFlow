% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{ContaminationFlow Linux}\label{chapter:Linux}
%\AddToShipoutPicture*{\ShowFramePicture}
\begin{itemize}[noitemsep,topsep=0pt]
\item Parallel simulation on several sub processes
\item Processing and control of data in main process
\item Update and accumulation of hit counters and other information such as profiles
\item SimulationHistory, final hitbuffer and used parameters exported to results folder
\end{itemize}
\smallskip

\begin{center}
\begin{tikzpicture}[node distance=2cm]
%\draw [help lines] (0,0) grid (4,4);
	\node (p0buffer)[textboxmed, rectangle split, rectangle split parts=2] at (0,10.5)
	{
		\textbf{Main Process 0}
		\nodepart{second} loadbuffer, hitbuffer
	};

	\node (p0loadbuffer)[textboxmed, rectangle split, rectangle split parts=2] at (0,8)
	{
		\textbf{Main Process 0}
		\nodepart{second} Broadcast loadbuffer
	};

	\node (p0hitbuffer)[textboxmed, rectangle split, rectangle split parts=2] at (0,5.5)
	{
		\textbf{Main Process 0}
		\nodepart{second} Broadcast hitbuffer
	};

	\node (p1geo)[textboxmed, rectangle split, rectangle split parts=2] at (5,6)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Load geometry
	};

	\node (p1upd)[textboxmed, rectangle split, rectangle split parts=2] at (5,4)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Update Quantities from hitbuffer
	};

	\node (p1sim)[textboxmed, rectangle split, rectangle split parts=2] at (5,1.7)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Simulation
	};

	\node (p1hit)[textboxmed, rectangle split, rectangle split parts=2] at (5,0)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Save information in hitbuffer\_1
	};

	\node (p0p1hit)[textboxmed, rectangle split, rectangle split parts=2] at (0,0)
	{
		\textbf{Main Process 0}
		\nodepart{second} hitbuffer +=\\ hitbuffer\_1
	};


	\node (pNgeo)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,6)
	{
		\textbf{Sub Process K}
		\nodepart{second} Load geometry
	};

	\node (pNupd)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,4)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Update Quantities from hitbuffer
	};

	\node (pNsim)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,1.7)
	{
		\textbf{Sub Process K}
		\nodepart{second} Simulation
	};

	\node (pNhit)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,0)
	{
		\textbf{Sub Process K}
		\nodepart{second} Save information in hitbuffer\_N-1
	};

	\node (p0pNhit)[textboxmed, rectangle split, rectangle split parts=2] at (0,-3.5)
	{
		\textbf{Main Process 0}
		\nodepart{second} hitbuffer += hitbuffer\_N-1
	};

	\node (p0upd)[textboxmed, rectangle split, rectangle split parts=2] at (0,-6)
	{
		\textbf{Main Process 0}
		\nodepart{second} Update real covering in hitbuffer
	};

	\draw let \p1=(p0buffer.second west) in [->, line width=0.04cm] (\x1-1.5cm,\y1) -- (\p1);
	\path let \p1=(p0buffer.second west) in node [above] at (\x1-0.75cm,\y1) {Import};

	\draw[->, line width=0.04cm] (p0buffer.south)--(p0loadbuffer.north);

	%\draw[->, line width=0.04cm] (1.9,7) -- (11.5,7)--(11.5,6.6);
	\draw let \p1=(p0loadbuffer.second east), \p2=(pNgeo.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	%\draw[->, line width=0.04cm] (5,7)--(5,6.6);
	\draw let \p1=(p0loadbuffer.second east), \p2=(p1geo.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	\draw[fill] let \p1=(p0loadbuffer.second east), \p2=(p1geo.north) in (\x2,\y1) circle [radius=0.05];
	\path let \p1=(p0loadbuffer.second east), \p2=(p1geo.west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	\draw let \p1=(p0hitbuffer.second east), \p2=(pNupd.north) in [->, line width=0.04cm] (\p1) -- (\x2-0.5cm,\y1)-- (\x2-0.5cm,\y2);
	\draw let \p1=(p0hitbuffer.second east), \p2=(p1upd.north) in [->, line width=0.04cm] (\p1) -- (\x2-0.5cm,\y1)-- (\x2-0.5cm,\y2);
	\draw[fill] let \p1=(p0hitbuffer.second east), \p2=(p1upd.north) in (\x2-0.5cm,\y1) circle [radius=0.05];
	\path let \p1=(p0hitbuffer.second east), \p2=(p1upd.west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	%\draw[fill] (8,6) circle [radius=0.06];
	%\draw[fill] (8.25,6) circle [radius=0.06];
	%\draw[fill] (8.5,6) circle [radius=0.06];
	\foreach \i in{-1,0,1}
		\draw[fill] let \p1=(p1geo.east), \p2=(pNgeo.west) in (0.5*\x1+0.5*\x2+0.25cm*\i,\y1) circle [radius=0.06];

	%\draw[->, line width=0.04cm] (11.5,5.3)--(11.5,4.86);
	\draw[->, line width=0.04cm] (pNgeo.south)--(pNupd.north);
	\draw[->, line width=0.04cm] (pNupd.south)--(pNsim.north);
	%\draw[->, line width=0.04cm] (5,5.3)--(5,4.86);
	\draw[->, line width=0.04cm] (p1geo.south)--(p1upd.north);
	\draw[->, line width=0.04cm] (p1upd.south)--(p1sim.north);
	%\draw[->, line width=0.04cm] (11.5,3.66)--(11.5,3.3);
	\draw[->, line width=0.04cm] (pNsim.south)--(pNhit.north);
	%\draw[->, line width=0.04cm] (5,3.66)--(5,3.3);
	\draw[->, line width=0.04cm] (p1sim.south)--(p1hit.north);

	%\draw[->, line width=0.04cm] (0,6.7)--(0,3.3);
	\draw[->, line width=0.04cm] (p0loadbuffer.south)--(p0hitbuffer.north);
	\draw[->, line width=0.04cm] (p0hitbuffer.south)--(p0p1hit.north);
	%\draw[<-, line width=0.04cm] (1.9,-1.1) -- (11.5,-1.1)--(11.5,1.53);
	\draw let \p1=(p0pNhit.second east), \p2=(pNhit.south) in [<-, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	%\draw[<-, line width=0.04cm] (1.9,2.3) -- (3.1,2.3);
	\draw[<-, line width=0.04cm] (p0p1hit.second east)--(p1hit.second west);
	

	\path let \p1=(p0pNhit.second east), \p2=(p1hit.second west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};
	\path let \p1=(p0p1hit.second east), \p2=(p1hit.second west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	\draw let \p1=(p0upd.second west) in [<-, line width=0.04cm] (\x1-1.5cm,\y1-0.2cm) -- (\x1,\y1-0.2cm);
	\path let \p1=(p0upd.second west) in node [below] at (\x1-0.75cm,\y1-0.2cm) {Export};

	%\draw[fill] (0,0.66) circle [radius=0.06];
	%\draw[fill] (0,0.41) circle [radius=0.06];
	%\draw[fill] (0,0.91) circle [radius=0.06];
	\foreach \i in{-1,0,1}
		\draw[fill] let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in (\x1,0.5*\y1+0.5*\y2+0.25cm*\i) circle [radius=0.06];

	%\draw[->, line width=0.04cm] (0,1.53)--(0,1.10);
	\draw let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in [->, line width=0.04cm] (\p1)--(\x1, 0.5*\y1+0.5*\y2+0.5cm);
	%\draw[->, line width=0.04cm] (0,0.2)--(0,-0.2);
	\draw let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in [<-, line width=0.04cm] (\p2)--(\x1, 0.5*\y1+0.5*\y2-0.5cm);

	\draw let \p1=(p0pNhit.south), \p2=(p0upd.north) in [->, line width=0.04cm] (\p1)--(\p2);
	\draw let \p1=(p0upd.second west), \p2=(p0hitbuffer.second west) in [->, line width=0.04cm] (\x1,\y1+0.2cm)--(\x1-1.5cm, \y1+0.2cm) -- (\x1-1.5cm,\y2) --(\p2);

	
\end{tikzpicture}
\end{center}

\section{Call of Application from Command line}
\subsection{Application with standard parameters}
Call Molflow Linux application with standard parameters in the command line:

\code{
\$ module load mpi\\
\$ mpirun -n N MolflowLinux loadbuffer hitbuffer save simulationtime unit}
\smallskip
with the following command line parameters:
\begin{itemize}[noitemsep,topsep=0pt]
\item n: desired number of worker processes; simulation on K=N-1 worker processes
\item MolflowLinux: path to application, e.g.\ \codew{\textasciitilde/MolflowLinux/Debug/MolflowLinux}
\item loadbuffer: path to loadbuffer file, contains geometry, e.g.\ \codew{\textasciitilde/loadbuffer}
\item hitbuffer: path to hitbuffer file, contains counters, etc., e.g.\ \codew{\textasciitilde/hitbuffer}
%\item resultbuffer: path to resultbuffer file, where the final hitbuffer is exported to,\\ e.g.\ \codew{\textasciitilde/resultbuffer}
\item save: determines whether result directory is created (1: true, 0:false), default:1
\item simulationtime: simulation time, e.g.\ \codew{2.5}
\item unit (optional): simulation time unit, e.g.\ \codew{min}; default: \codew{s}
\end{itemize}

\subsection{Application with custom parameters}
Call Molflow Linux application with custom parameters in the command line:
\code{
\$ module load mpi\\
\$ mpirun -n N MolflowLinux inputfile save}
\smallskip
with the following command line parameters:
\begin{itemize}[noitemsep,topsep=0pt]
\item inputfile: path to file that defines simulation parameters
\item save: determines whether result directory is created (1: true, 0:false), default:1
\end{itemize}
\bigskip

and the input file defining the following parameters:
\begin{itemize}[noitemsep,topsep=0pt]
\item n: desired number of worker processes; simulation on K=N-1 worker processes
\item MolflowLinux: path to application, e.g.\ \codew{\textasciitilde/MolflowLinux/Debug/MolflowLinux}
\item loadbufferPath: path to loadbuffer file, contains geometry, e.g.\ \codew{\textasciitilde/loadbuffer}
\item hitbufferPath: path to hitbuffer file, contains counters, etc., e.g.\ \codew{\textasciitilde/hitbuffer}
%\item resultbufferPath: path to resultbuffer file, where the final hitbuffer is exported to,\\ e.g.\ \codew{\textasciitilde/resultbuffer}
\item simulationTime: simulation time per iteration step; default: \codew{10.0}
\item unit: simulation time unit; default: \codew{s}
\item maxTime: maximum simulation time; default: \codew{10.0}
\item maxUnit: maximum simulation time unit; default: \codew{y}
\item iterationNumber: number of iterations; default: 43200
%\item \codew{$s_1$}, coefficient used for calculation of sticking coefficient; default:\codew{1}
%\item \codew{$s_2$}, coefficient used for calculation of sticking coefficient; default:\codew{0.2}
%\item \codew{$E_{ad}$}, energy used for calculation of sticking coefficient; default:\codew{1\text{E}-21}
\item\codew{$d$}, power for base of coverage used for calculation of desorption; default:\codew{1}
\item \codew{$E_{de}$}, maximum energy used for calculation of desorption; default:\codew{1\text{E}-21}
\item \codew{$H_{vap}$}, minimum energy used for calculation of desorption; default:\codew{1\text{E}-21}
\item \codew{$W_{tr}$}, window width used for calculation of desorption; default:\codew{1\text{E}-21}
\item \codew{$sticking$}, constant sticking coefficient for all facets; default:\codew{0.8\text{E}-19}
\end{itemize}

\section{Application}
\subsection{General Changes}

\subsubsection{Replacement/removal of Windows libraries/functions}
\begin{itemize}[noitemsep,topsep=0pt]
\item Databuff struct with import/export instead of using Dataports
\item Replacements of libraries, e.g.\ \codew{\#include <time.h>} with \codew{\#include <sys/time.h>}
\end{itemize}

\subsubsection{Removal of functions used in \codew{AC\_MODE}}
\begin{itemize}[noitemsep,topsep=0pt]
\item Only \codew{MC\_MODE} used
\item Removal of \codew{AC\_MODE} cases and functions
\end{itemize}

\subsubsection{New class ProblemDef}
\begin{itemize}[noitemsep,topsep=0pt]
\item Defines parameters used for simulation
\item Possible adaptation of paramaters through input file or command line arguments
\item Conducts some intern conversions
\item Creates result folder for each simulation
\end{itemize}

\subsubsection{Result Directory}
\begin{itemize}[noitemsep,topsep=0pt]
\item Final resultbuffer
\item Final covering, input file and console output as text files
\end{itemize}
\subsection{Communication}
\subsubsection{Import and export of buffer files}
\begin{itemize}[noitemsep,topsep=0pt]
\item New Databuff struct \code{typedef unsigned char BYTE;\\typedef struct \{\\
	\hphantom{\quad}signed int size;\\
	\hphantom{\quad}BYTE *buff;\\
\} Databuff;}
\item New functions \codew{importBuff($\cdot$)} and \codew{exportBuff($\cdot$)} for import of buffer files and export of Databuff struct
\item New functions \codew{checkReadable($\cdot$)} and \codew{checkWriteable($\cdot$)} to check if file is readable or writeable
\end{itemize}

\subsubsection{Communication between worker processes via MPI}
\begin{itemize}[noitemsep,topsep=0pt]
\item Main process 0 sends Databuff struct containing loadbuffer and Databuff struct containing hitbuffer to sub processes using \codew{MPI\_Bcast($\cdot$)}
\item Sub processes send updated Databuff struct containing hitbuffer to main process 0 using \codew{MPI\_Send($\cdot$)} and \codew{MPI\_Recv($\cdot$)}
\end{itemize}

\subsection{New Quantities}
\label{sub:quant}
\subsubsection{New counter \codew{covering}}
\begin{itemize}[noitemsep,topsep=0pt]
\item Number of carbon equivalent particles on facet
\item Added covering counter to hitbuffer
\item Extracted from hitbuffer from \codew{Simulationcalc.cpp} file in \codew{getCovering($\cdot$)}
\item Covering increases with adsorption, decreases with desorption
\end{itemize}

\subsubsection{Coverage}
\begin{itemize}[noitemsep,topsep=0pt]
\item Number of carbon equivalent particles per monolayer on facet
\item Calculated from covering, gas mass and facet area
\item Coverage computed from \codew{Simulationcalc.cpp} file in \codew{calcCoverage($\cdot$)}
\end{itemize}

\subsubsection{Sticking factor}
\begin{itemize}[noitemsep,topsep=0pt]
\item Ratio adsorbed particles to impinging particles
\item Set to 0, can be adapted through input file
%\item Calculated from coverage (and temperature)
%\item Sticking factor computed from \codew{Simulationcalc.cpp} file in \codew{calcStickingnew($\cdot$)}
%\item Updated and fixed before each interation
\end{itemize}

\subsubsection{Binding energy}
\begin{itemize}[noitemsep,topsep=0pt]
\item Calculate energy using \codew{$E_{de}$}, \codew{$H_{vap}$} and \codew{$W_{tr}$}
\item Desorption computed from \codew{Simulationcalc.cpp} file in \codew{calcEnergy($\cdot$)}
\end{itemize}

\subsubsection{Desorption $[1/\text{s}]$}
\begin{itemize}[noitemsep,topsep=0pt]
\item Calculated from energy, covering and temperature
\item Desorption computed from \codew{Simulationcalc.cpp} file in \codew{calcDesorption($\cdot$)}
\end{itemize}

\subsubsection{Desorption Rate $[\text{Pa m}^3/\text{s}]$}
\begin{itemize}[noitemsep,topsep=0pt]
\item Calculated from desorption, gas mass and facet area
\item Desorption rate computed from \codew{Simulationcalc.cpp} file in \codew{calcDesorptionRate($\cdot$)}
\item Used to determine starting point for new particle
\item Updated and fixed before each interation
\end{itemize}

%\subsubsection{\codew{Worker} class for Worker processes}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Reduced \codew{Worker} class
%\item Only use of functions \codew{GetCDFId($\cdot$)}, \codew{GenerateNewCDF($\cdot$)}, \codew{Generate\_CDF($\cdot$)}, \codew{CalcTotalOutgassing()}
%\end{itemize}
\subsubsection{Outgassing Rate}
\begin{itemize}[noitemsep,topsep=0pt]
\item Calculated from sHandle values: facet outgassing and temerature
\item Outgassing rate computed from \codew{Worker.cpp} file in \codew{CalcTotalOutgassingWorker()}
\end{itemize}

\subsubsection{$\text{K}_{\text{real}/\text{virtual}}$}
\begin{itemize}[noitemsep,topsep=0pt]
\item Number of real particles represented by test particles
\item Calculated from desorption rate, outgassing rate and number of desorbed molecules
\item $\text{K}_{\text{real}/\text{virtual}}$ computed from \codew{Simulationcalc.cpp} file in \codew{GetMoleculesPerTP($\cdot$)}
\end{itemize}

\newpage
\subsection{Iterative algorithm}
\subsubsection{General Pipeline}
\begin{itemize}[noitemsep,topsep=0pt]
\item Initialize MPI to have desired number of processes (minimum 2)
\item Send loadbuffer from main process 0 to sub processes using MPI and create sHandle and load geometry using \codew{InitSimulation()} and \codew{LoadSimulation()} in all processes
\item Start iteration: iterationNumber steps of length simulationTime * unit:
	\begin{itemize}[noitemsep,topsep=0pt]
	\item[$\bullet$] Send hitbuffer from main process to subprocess using MPI
	\item[$\bullet$] Update desorption rate and sojourn frequency/energy in sub processes using \codew{UpdateDesorptionRate($\cdot$)} and \codew{UpdateSojourn($\cdot$)} from \codew{UpdateSubProcess.cpp}
	\item[$\bullet$] Simulate for SimulationTime * unit using \codew{SimulationRun()}
	\item[$\bullet$] Update hitbuffer of sub processes from sHandle using \codew{UpdateSubHits($\cdot$)} from \codew{UpdateSubProcess.cpp}
	\item[$\bullet$] Update Main process:
		\begin{itemize}[noitemsep,topsep=0pt]
		\item[$\bullet$] Send hitbuffer from sub process to main process using MPI
		\item[$\bullet$] Update hitbuffer of main process from sub process in \codew{UpdateMainHits($\cdot$)} from \codew{UpdateMainProcess.cpp}
		\end{itemize}
	\item[$\bullet$] Calculate real covering in main process using $\text{K}_{\text{real}/\text{virtual}}$ and simulated time step in \codew{UpdateCovering($\cdot$)} from \codew{UpdateMainProcess.cpp}, save in SimulationHistory
	\item[$\bullet$] Update real covering in hitbuffer of main process in \codew{UpdateCoveringphys($\cdot$)} from \codew{UpdateMainProcess.cpp}
	\end{itemize}
\item Export final results (hitbuffer and simulationHistory) to results folder
\end{itemize}

\subsubsection{New class to store Simulation History}
\begin{itemize}[noitemsep,topsep=0pt]
\item SimulationHistory class \code{class SimulationHistory \{\\
	public:\\
	\hphantom{\quad}SimulationHistory();\\
	\hphantom{\quad}SimulationHistory(Databuff *hitbuffer);\\
	\hphantom{\quad}HistoryList<llong> coveringList;\\
	\hphantom{\quad}double flightTime;\\
	\hphantom{\quad}int nParticles;\\
	\hphantom{\quad}int currentStep;\\
	\\
	\hphantom{\quad}void appendList(Databuff *hitbuffer, double time);\\
	\hphantom{\quad}void print();\\
	\hphantom{\quad}void write(std::string path);\\
\};}
\code{template <typename T> class HistoryList \{\\
	public:\\
	\hphantom{\quad}HistoryList();\\
	\hphantom{\quad}std::vector<std::pair<double,std::vector<T> > > pointintime\_list;\\
	\hphantom{\quad}std::vector<T> currentList;\\
\};}
\item In \codew{SimulationLinux.h} and \codew{SimulationLinux.cpp} file
\item SimulationHistory updated after each iterarion in \codew{UpdateCovering($\cdot$)} from \codew{UpdateMainProcess.cpp} file
\item Currently recorded quantities: covering for all facets
\item Time given in simulated time (accumulated time steps) rather than computed time 
\end{itemize}

\subsubsection{Set covering threshold}
\begin{itemize}[noitemsep,topsep=0pt]
\item Set lower threshhold for covering for each facet to prevent covering getting negative
\item Stop simulation once threshold is reached
\item Threshold set in \codew{setCoveringThreshold($\cdot$)}  from \codew{Iteration.cpp} file
\end{itemize}

%\subsubsection{Estimation of time step \codew{$T_{min}$}}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Determines minimum timestep for simulation, average time between outgassing/desorption and adsorption
%\item $T_{min}$ computed in \codew{Iteration.cpp} file in \codew{estimateAverageFlightTime()} using simulationHistory: $\text{flightTime}/\text{nParticles}$ 
%\end{itemize}
%
%\subsubsection{Management of time step \codew{$T_{min}$}}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item Currently not used
%\item Chooses larger value between \codew{estimateAverageFlightTime()} and \codew{getStepSize()}
%\item Checks whether current time step would cause covering to get negative
%\item Adapts time step if needed
%\item Increments \codew{SimulationHistory::currentStep} if \codew{getStepSize()} chosen and not decreased
%\item Management in \codew{UpdateMainProcess.cpp} file in \codew{manageTimeStep($\cdot$)}
%\end{itemize}

\subsubsection{Calculate Step Size}
\begin{itemize}[noitemsep,topsep=0pt]
\item Uses \codew{SimulationHistory::currentStep} to calculate logarithmic step size
\item Duration between outgassing/desorption and adsorption
\end{itemize}

\subsubsection{Management of Step Size}
\begin{itemize}[noitemsep,topsep=0pt]
\item Checks whether current step size would cause desorption to be larger than covering 
\item Adapts time step if needed
\item Increments if step size not decreased
\item Management in \codew{UpdateMainProcess.cpp} file in \codew{manageStepSize($\cdot$)}
\end{itemize}

\subsubsection{Management of Simulation Time}
\begin{itemize}[noitemsep,topsep=0pt]
\item Increases simulation time (=computation time) per iteration if not enough particles desorbed
\item Adapts simulation time if needed
\item If enough desorption: compute maximum ratio $step size/computation time$
\item If not enough desorption: adapt computation time using ration $step size/computation time$
\item Management in \codew{UpdateMainProcess.cpp} file in \codew{manageSimulationTime($\cdot$)}
\end{itemize}

\subsubsection{Error Calculation}
\begin{itemize}[noitemsep,topsep=0pt]
\item Calculates statistical error dependent on hits for every facet, weighted with opacity of that facet
\item TODO weighting for total error
\end{itemize}

\subsubsection{Sojourn}
\begin{itemize}[noitemsep,topsep=0pt]
\item Sojourn time of bounce calculated from energy and frequency
\end{itemize}

%\subsubsection{Thats changed}
%\begin{itemize}[noitemsep,topsep=0pt]
%\item use this for 
%\item list
%\end{itemize}


