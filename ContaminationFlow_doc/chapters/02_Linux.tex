% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{ContaminationFlow Linux}\label{chapter:Linux}
%\AddToShipoutPicture*{\ShowFramePicture}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Parallel simulation on several sub processes
\item Processing and control of data in main process
\item Update and accumulation of hit counters and other information such as profiles
\item \codew{SimulationHistory}, simulation parameters, console output exported to results folder
\end{itemize}
\smallskip
\begin{figure}[hb]
\centering
\begin{tikzpicture}[node distance=2cm, font=\scriptsize]
%\draw [help lines] (0,0) grid (4,4);
	\node (p0buffer)[textboxmed, rectangle split, rectangle split parts=2, text width=5.5cm] at (1,10.8)
	{
		\textbf{Main Process 0}
		\nodepart{second}\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*] \item Input file: sets simulation parameters\item loadbuffer: directly imported \item hitbuffer: directly imported or indirectly by covering file\end{itemize}
	};

	\node (p0loadbuffer)[textboxmed, rectangle split, rectangle split parts=2] at (0,8)
	{
		\textbf{Main Process 0}
		\nodepart{second} Broadcast loadbuffer
	};

	\node (p0hitbuffer)[textboxmed, rectangle split, rectangle split parts=2] at (0,6)
	{
		\textbf{Main Process 0}
		\nodepart{second} Broadcast covering, currentStep from SimulationHistory
	};

	\node (p1geo)[textboxmed, rectangle split, rectangle split parts=2] at (5,6.5)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Load geometry
	};

	\node (p1upd)[textboxmed, rectangle split, rectangle split parts=2] at (5,4.5)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Update Quantities from SimulationHistory
	};

	\node (p1sim)[textboxmed, rectangle split, rectangle split parts=2] at (5,2.4)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Simulation
	};

	\node (p1hit)[textboxmed, rectangle split, rectangle split parts=2] at (5,0.7)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Save information in hitbuffer\_1
	};

	\node (p0p1hit)[textboxmed, rectangle split, rectangle split parts=2] at (0,0.7)
	{
		\textbf{Main Process 0}
		\nodepart{second} hitbuffer +=\\ hitbuffer\_1
	};


	\node (pNgeo)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,6.5)
	{
		\textbf{Sub Process K}
		\nodepart{second} Load geometry
	};

	\node (pNupd)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,4.5)
	{
		\textbf{Sub Process 1}
		\nodepart{second} Update Quantities from SimulationHistory
	};

	\node (pNsim)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,2.4)
	{
		\textbf{Sub Process K}
		\nodepart{second} Simulation
	};

	\node (pNhit)[textboxmed, rectangle split, rectangle split parts=2] at (10.6,0.7)
	{
		\textbf{Sub Process K}
		\nodepart{second} Save information in hitbuffer\_K
	};

	\node (p0pNhit)[textboxmed, rectangle split, rectangle split parts=2] at (0,-2.5)
	{
		\textbf{Main Process 0}
		\nodepart{second} hitbuffer += hitbuffer\_K
	};

	\node (p0upd)[textboxmed, rectangle split, rectangle split parts=2] at (0,-4.7)
	{
		\textbf{Main Process 0}
		\nodepart{second} \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]\item Update real covering in hitbuffer\item Update SimulationHistory\end{itemize}
	};

	\draw let \p1=(p0buffer.second west) in [->, line width=0.04cm] (\x1-1.5cm,\y1) -- (\p1);
	\path let \p1=(p0buffer.second west) in node [above] at (\x1-0.75cm,\y1) {Import};

	\draw[->, line width=0.04cm] ([xshift=-1cm]p0buffer.south)--(p0loadbuffer.north);

	%\draw[->, line width=0.04cm] (1.9,7) -- (11.5,7)--(11.5,6.6);
	\draw let \p1=(p0loadbuffer.second east), \p2=(pNgeo.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	%\draw[->, line width=0.04cm] (5,7)--(5,6.6);
	\draw let \p1=(p0loadbuffer.second east), \p2=(p1geo.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	\draw[fill] let \p1=(p0loadbuffer.second east), \p2=(p1geo.north) in (\x2,\y1) circle [radius=0.05];
	\path let \p1=(p0loadbuffer.second east), \p2=(p1geo.west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	\draw let \p1=(p0hitbuffer.second east), \p2=(pNupd.north) in [->, line width=0.04cm] (\p1) -- (\x2-0.5cm,\y1)-- (\x2-0.5cm,\y2);
	\draw let \p1=(p0hitbuffer.second east), \p2=(p1upd.north) in [->, line width=0.04cm] (\p1) -- (\x2-0.5cm,\y1)-- (\x2-0.5cm,\y2);
	\draw[fill] let \p1=(p0hitbuffer.second east), \p2=(p1upd.north) in (\x2-0.5cm,\y1) circle [radius=0.05];
	\path let \p1=(p0hitbuffer.second east), \p2=(p1upd.west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	%\draw[fill] (8,6) circle [radius=0.06];
	%\draw[fill] (8.25,6) circle [radius=0.06];
	%\draw[fill] (8.5,6) circle [radius=0.06];
	\foreach \i in{-1,0,1}
		\draw[fill] let \p1=(p1geo.east), \p2=(pNgeo.west) in (0.5*\x1+0.5*\x2+0.25cm*\i,\y1) circle [radius=0.06];

	%\draw[->, line width=0.04cm] (11.5,5.3)--(11.5,4.86);
	\draw[->, line width=0.04cm] (pNgeo.south)--(pNupd.north);
	\draw[->, line width=0.04cm] (pNupd.south)--(pNsim.north);
	%\draw[->, line width=0.04cm] (5,5.3)--(5,4.86);
	\draw[->, line width=0.04cm] (p1geo.south)--(p1upd.north);
	\draw[->, line width=0.04cm] (p1upd.south)--(p1sim.north);
	%\draw[->, line width=0.04cm] (11.5,3.66)--(11.5,3.3);
	\draw[->, line width=0.04cm] (pNsim.south)--(pNhit.north);
	%\draw[->, line width=0.04cm] (5,3.66)--(5,3.3);
	\draw[->, line width=0.04cm] (p1sim.south)--(p1hit.north);

	%\draw[->, line width=0.04cm] (0,6.7)--(0,3.3);
	\draw[->, line width=0.04cm] (p0loadbuffer.south)--(p0hitbuffer.north);
	\draw[->, line width=0.04cm] (p0hitbuffer.south)--(p0p1hit.north);
	%\draw[<-, line width=0.04cm] (1.9,-1.1) -- (11.5,-1.1)--(11.5,1.53);
	\draw let \p1=(p0pNhit.second east), \p2=(pNhit.south) in [<-, line width=0.04cm] (\p1) -- (\x2,\y1)-- (\p2);
	%\draw[<-, line width=0.04cm] (1.9,2.3) -- (3.1,2.3);
	\draw[<-, line width=0.04cm] (p0p1hit.second east)--(p1hit.second west);
	

	\path let \p1=(p0pNhit.second east), \p2=(p1hit.second west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};
	\path let \p1=(p0p1hit.second east), \p2=(p1hit.second west) in node [above] at (0.5*\x1+0.5*\x2,\y1) {MPI};

	\draw let \p1=(p0upd.second west) in [<-, line width=0.04cm] (\x1-1.5cm,\y1-0.2cm) -- (\x1,\y1-0.2cm);
	\path let \p1=(p0upd.second west) in node [below, text width=1.5cm] at (\x1-0.75cm,\y1-0.2cm) {Export SimulationHistory};

	%\draw[fill] (0,0.66) circle [radius=0.06];
	%\draw[fill] (0,0.41) circle [radius=0.06];
	%\draw[fill] (0,0.91) circle [radius=0.06];
	\foreach \i in{-1,0,1}
		\draw[fill] let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in (\x1,0.5*\y1+0.5*\y2+0.25cm*\i) circle [radius=0.06];

	%\draw[->, line width=0.04cm] (0,1.53)--(0,1.10);
	\draw let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in [->, line width=0.04cm] (\p1)--(\x1, 0.5*\y1+0.5*\y2+0.5cm);
	%\draw[->, line width=0.04cm] (0,0.2)--(0,-0.2);
	\draw let \p1=(p0p1hit.south), \p2=(p0pNhit.north) in [<-, line width=0.04cm] (\p2)--(\x1, 0.5*\y1+0.5*\y2-0.5cm);

	\draw let \p1=(p0pNhit.south), \p2=(p0upd.north) in [->, line width=0.04cm] (\p1)--(\p2);
	\draw let \p1=(p0upd.second west), \p2=(p0hitbuffer.second west) in [->, line width=0.04cm] (\x1,\y1+0.2cm)--(\x1-1.5cm, \y1+0.2cm) -- (\x1-1.5cm,\y2) --(\p2);	
\end{tikzpicture}
\caption{Processing of data in main and sub processes}
\end{figure}


\section{Call of Application from Command line}

\subsubsection{New class ProblemDef}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Defines parameters used for simulation
\item Possible adaptation of default paramaters through input file
%\item Conducts some intern conversions
\item Creates result folder for simulation if desired:
	\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
	%\item Final hitbuffer
	\item Final covering, error, pressure, particle density as text files
	\item Input file and console output as text files
	\end{itemize}
\end{itemize}
%\bigskip

\subsubsection{Application with custom parameters using input file}
\textbf{Requirements:} Input and buffer files readable, N $\geq$ 2, zero moments in loadbuffer\\[4pt]
Call of ContaminationFlow Linux application in the command line:
\code{
\$ module load mpi\\
\$ mpirun -n N --options \ MolflowLinux inputfile save}
\leavevmode\\[-8pt]
with the following MPI \codew{--options}:
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item  (No option): use processor cores (recommended if possible)
\item \codew{--use-hwthread-cpus}: use hardware threads instead processor cores (recommended if N $>$ number cores)
\item \codew{--oversubscribe}: ignore available slots, for any number of MPI processes
\end{itemize}
\bigskip
and command line parameters:
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item \codew{N}: desired number of worker processes; simulation on K=N-1 worker processes
\item \codew{MolflowLinux}: path to application, e.g.\ \codew{\textasciitilde/MolflowLinux/Debug/MolflowLinux}
\item \codew{inputfile}: path to file that defines simulation parameters
\item \codew{save}: determines whether result directory is created (1: true, 0:false); default:\codew{1}
\end{itemize}
\bigskip
and the input file defining the following parameters:
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item \codew{$loadbufferPath$}: Path to loadbuffer file, contains geometry, e.g.\ \codew{\textasciitilde/loadbuffer}
\item \codew{$hitbufferPath$}: Path to hitbuffer file, contains counters, etc., e.g.\ \codew{\textasciitilde/hitbuffer}
\item \codew{$coveringPath$}: Path to covering file, contains either covering or coverage per facet, file can be exported from ContaminationFlow Windows, e.g.\ \codew{\textasciitilde/covering.txt}; default: \codew{""}
%\item resultbufferPath: path to resultbuffer file, where the final hitbuffer is exported to,\\ e.g.\ \codew{\textasciitilde/resultbuffer}
\item \codew{$simulationTime$}: Simulation time per iteration step; default: \codew{10.0}
\item \codew{$unit$}: Simulation time unit; default: \codew{s}
\item \codew{$maxTime$}: Max.\ simulated time; default: \codew{10.0}
\item \codew{$maxUnit$}: Max.\ simulated time unit; default: \codew{y}
\item \codew{$iterationNumber$}: Number of iterations; default: 43200
%\item \codew{$s_1$}, coefficient used for calculation of sticking coefficient; default:\codew{1}
%\item \codew{$s_2$}, coefficient used for calculation of sticking coefficient; default:\codew{0.2}
%\item \codew{$E_{ad}$}, energy used for calculation of sticking coefficient; default:\codew{1\text{E}-21}
%\item\codew{$d$}: power for base of coverage used for calculation of desorption; default:\codew{1}
\item \codew{$particleDia$}: Diameter of particles; default:\codew{2.76\text{E}-10}
\item \codew{$E_{de}$}: Binding energy of a particle on pure substrate; default:\codew{1.6\text{E}-19}
\item \codew{$H_{vap}$}: Vaporization enthalpy of a particle if multilayer contamination; default:\codew{0.8\text{E}-19}
%\item \codew{$W_{tr}$}: transition width between monolayer and multilayer properties; default:\codew{1}
\item \codew{$sticking$}: Constant sticking coefficient for all facets; default:\codew{0}
%\item \codew{$coveringLimit$}: threshold for zero desoprtion; default:\codew{0}
\item \codew{$errorMode$}: Type of error monitored, "covering" or "event"; default: \codew{covering}
\item \codew{$targetPaticles$}: Min.\ number of desorbed particles per iteration; default: \codew{1000}
\item \codew{$targetError$}: Avg.\ statistical uncertainty (error) to be achieved for each iteration, calculated as the avg.\ (weighted with the facets area) of the normalized standard deviation of events per facet; default: \codew{0.001}
\item \codew{$hitRatioLimit$}: Ratio (facet/all), e.g., number events or covering change, at which facet is ignored for error calculation; default: \codew{0}
\item \codew {$t\_min$}: Min.\ time for step size; default:\codew{1\text{E}-4}
\item \codew{$t\_max$}: Max.\ time for step size; default:\codew{max}
\item \codew{$maxTimePerIt$}: Max.\ simulation time [s] per iteration; default:\codew{max}
\item \codew{$coveringMinThresh$}: Min.\ covering (through multiplication); default:\codew{1000000}
\item \codew{$histsize$}: Size of history lists; default:\codew{max}
\item \codew{$vipFacets$}: Very important facets: facets with own target error. Alternating sequence of facet numbers and respective target errors separated via blanks; default:\codew{[]}
\item \codew{$outgassingTimeWindow$}: Duration [s] of outgassing impulse; default: \codew{0.0}
\item \codew{$counterWindowPercent$}: Percentage of step size (posterior) at which velocity counters are increased; default: \codew{0.1}
\item \codew{$desWindowPercent$}: Percentage of step size (anterior) at which desorption occurs; default: \codew{1.0}
\item \codew{$rollingWindowSize$}: Number of iterations for avg.\ statistics; default: \codew{10}
\item \codew{$convergenceTarget$}: Target for avg.\ statistics to indicate convergence; default: \codew{1}
\item \codew{$stopConverged$}: Stop simulation if avg.\ statistics indicate convergence; default: \codew{1}
\item \codew{$convergenceTime$}: Min.\ simulated time to stop simulation if converged; default: \codew{0}
\item \codew{$facetGroups$}:  Indices of facets belonging to a group, groups divided by -; default:\codew{[]}
\item \codew{$focusGroup$}: Indices of facet groups to be monitored; default:\codew{[]}
\item \codew{$doFocusGroupOnly$}: Determines of only facetGroup facets are monitored facets; default:\codew{1}
\end{itemize}
\bigskip
Optional covering file to replace hitbuffer. Hitbuffer will not be imported if covering file is given. There are two options (that can both be exported from ContaminationFlow Windows):
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item  set covering: \codew{covering} followed by covering values per facet, seperated via blanks
\item  set coverage: \codew{coverage} followed by coverage values per facet, seperated via blanks
\end{itemize}
%\section{General Changes}
%
%\subsubsection{Replacement/removal of Windows libraries/functions}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Databuff struct with import/export instead of using Dataports
%\item Replacements of libraries, e.g.\ \codew{\#include <time.h>} with \codew{\#include <sys/time.h>}
%\end{itemize}
%
%\subsubsection{Removal of functions used in \codew{AC\_MODE}}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Only \codew{MC\_MODE} used
%\item Removal of \codew{AC\_MODE} cases and functions
%\end{itemize}

\subsubsection{Terminology}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Simulation time: desired computation time until check if target is reached for iteration
\item Simulated time: physical time in the simulated system, e.g.\ flight time of particle
\item Maximum simulated time: desired total simulated time
\item Step size: desired simulated time per particle for iteration
\end{itemize}

\section{Communication}
\subsubsection{Import and export of buffer files}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item New Databuff struct that replaces Dataport struct from MolFlow Windows
\end{itemize}
\code{typedef unsigned char BYTE;\\typedef struct \{\\
	\hphantom{\quad}signed int size;\\
	\hphantom{\quad}BYTE *buff;\\
\} Databuff;}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item New function \codew{initBuffSize($\cdot$)} to initialize buffer size
\item New functions \codew{importBuff($\cdot$)}/\codew{exportBuff($\cdot$)} to import buffer/export Databuff struct
\item New functions \codew{checkReadable($\cdot$)}/\codew{checkWriteable($\cdot$)} to check if file is readable/writeable
\end{itemize}

\subsubsection{Communication between worker processes via MPI}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Main process 0 sends Databuff structs containing loadbuffer/hitbuffer and required simulationHistory values to sub processes using \codew{MPI\_Bcast($\cdot$)}
\item Sub processes send updated Databuff struct containing hitbuffer and required simulationHistory values to main process 0 using \codew{MPI\_Send($\cdot$)} and \codew{MPI\_Recv($\cdot$)}
\end{itemize}

\section{Usage of $boost$ Library}
\subsubsection{Multiprecision}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Increase precision for variables if required (float128, uint\_128t)
\item Avoid overflow for integer and underflow for floating point numbers
\end{itemize}
\newpage
\section{New Quantities}
\label{sub:quant}
\subsubsection{New counter \codew{covering}}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of carbon equivalent particles on facet
\item Increases with adsorption, decreases with desorption
\item Extracted from new FacetHitBuffer counter in \codew{getCovering($\cdot$)} (\codew{Simulationcalc.cpp})
\end{itemize}

\subsubsection{Coverage}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of monolayers of adsorbed particles
\item Calculated from covering, particle diameter (previously gas mass) and facet area
\item Coverage computed in \codew{calcCoverage($\cdot$)} (\codew{Simulationcalc.cpp})
\end{itemize}

\subsubsection{Sticking factor}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Ratio adsorbed particles to impinging particles
\item Set to value specified in input file in \codew{calcStickingnew($\cdot$)} (\codew{Simulationcalc.cpp})
\end{itemize}

\subsubsection{Binding energy}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Either \codew{$E_{de}$} or \codew{$H_{vap}$}, depending on the how many layers of particles are adsorbed.
\item If coverage is smaller than a monolayer, it will be decided at random.
\item Used in \codew{StartFromSource($\cdot$)} \& \codew{PerformBounce($\cdot$)} (\codew{SimulationMC.cpp}) and\\ \codew{calcDesorption($\cdot$)} \& \codew{calcStartTime($\cdot$)} (\codew{SimulationCalc.cpp})
%\item Calculated from \codew{$E_{de}$}, \codew{$H_{vap}$} and \codew{$W_{tr}$}
%\item Energy computed from \codew{Simulationcalc.cpp} file in \codew{calcEnergy($\cdot$)}
\end{itemize}

\subsubsection{Desorption}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of particles desorbing
\item Calculated from binding energy, covering, temperature and step size
\item Desorption computed in \codew{calcDesorption($\cdot$)} (\codew{Simulationcalc.cpp})
\end{itemize}

\subsubsection{Outgassing}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of particles from outgassing
\item Calculated from facet outgassing, temperature, and outgassing time
\item Outgassing computed in \codew{CalcTotalOutgassingWorker()} (\codew{Worker.cpp})
\end{itemize}

\subsubsection{$K_{\text{real}/\text{virtual}}$}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Number of real particles represented by test particles
\item Calculated from desorption \& outgassing and number of desorbed molecules
\item $K_{\text{real}/\text{virtual}}$ computed in \codew{GetMoleculesPerTP($\cdot$)} (\codew{Simulationcalc.cpp})
\end{itemize}

\subsubsection{Statistical error}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Event error: calculated from hits and desorbed particles (of facet and total)
\item Covering error: calculated from adsorbed and desorbed particles (of facet and total)
\item Used to determine significance of simulation results of iteration
\item Error calculated in \codew{UpdateErrorList($\cdot$)} for facet error \& \codew{UpdateErrorAll($\cdot$)} for average error weighted with area (\codew{UpdateSubProcess.cpp})
\end{itemize}

\subsubsection{Step size}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Minimum time between adsorption and desorption
\item Step size computed in \codew{getStepSize()} (\codew{UpdateMainProcess.cpp})
\end{itemize}

\subsubsection{Particle density}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculated from sum over reciprocal of orthogonal velocity, facet area and $K_{\text{real}/\text{virtual}}$
\item Particle density computed in \codew{calcParticleDensity($\cdot$)} (\codew{Simulationcalc.cpp})
\end{itemize}

\subsubsection{Pressure}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculated from sum over orthogonal velocity, facet area, gas mass and $K_{\text{real}/\text{virtual}}$
\item Pressure computed in \codew{calcPressure($\cdot$)} (\codew{Simulationcalc.cpp})
\end{itemize}

\subsubsection{Start time}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Determines time of desorption/outgassing for particle based on the distribution
\item Desorption rate: exponential distribution for whole iteration
\item Outgassing: uniform distribution of limited time for whole simulation
\item Start time computed in \codew{calcStartTime($\cdot$)} (\codew{Simulationcalc.cpp})
\end{itemize}


\section{Iterative Algorithm}

\subsection{Initialization of simulation}
\begin{figure}[!htb]
\centering
\begin{tikzpicture}[node distance=2cm, font=\scriptsize]
	\tikzstyle{condition} = [diamond, draw, minimum width= 4cm, align=center,  aspect=1.5]
	\tikzstyle{module} = [ellipse,draw, minimum width= 4cm, align=center, aspect=1.5]
	\tikzstyle{neuron}= [rectangle,draw, minimum width= 4cm, align=center, aspect=1.5]

	\node[module](start)  at (0,-0.2) {Start\\Initialization};
	\node[neuron](input) at (0,-2) {Load parameters\\from input file};
	\draw let \p1=(start.south), \p2=(input.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](load) at (0,-3.5) {Main process:\\Import loadbuffer\\and broadcast};
	\draw let \p1=(input.south), \p2=(load.north) in [->, line width=0.04cm] (\p1) -- (\p2);
	\node[neuron](geom) at (5,-3.5) {Load geometry \&\\init simHistory};
	\draw let \p1=(load.east), \p2=(geom.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[condition](covfile) at (5,-2){Covering\\File?};
	\draw let \p1=(geom.north), \p2=(covfile.south) in [->, line width=0.04cm] (\p1) -- (\p2);
	\node[neuron](hit) at (10,-2) {Main process:\\Import hitbuffer\\and broadcast};
	\draw let \p1=(covfile.east), \p2=(hit.west) in [->, line width=0.04cm] (\p1) -- (\p2)node[midway,above]{false};
	\node[neuron](hit2) at (5,-0.2) {Main process:\\Initialize hitbuffer from \\covering file and broadcast};
	\draw let \p1=(covfile.north), \p2=(hit2.south) in [->, line width=0.04cm] (\p1) -- (\p2)node[midway,right]{true};
	

	\node[module](end)  at (10,-0.2) {End\\Initialization};
	\draw let \p1=(hit.north), \p2=(end.south) in [->, line width=0.04cm] (\p1) -- (\p2);
	\draw let \p1=(hit2.east), \p2=(end.west) in [->, line width=0.04cm] (\p1) -- (\p2);

\end{tikzpicture}
\caption{Overview: Initialize simulation}
\end{figure}

\subsubsection{New class to store Simulation History}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item HistoryList and SimulationHistory class in \codew{SimulationLinux.h} and \codew{SimulationLinux.cpp} file
\end{itemize}
\code{template <typename T> class HistoryList \{\\
	public:\\
	\hphantom{\enskip}HistoryList();\\
	\hphantom{\enskip}pair<vector<double>,vector<vector<T>>> historyList;{\color{gray}//(vec(time), vec(facets))}\\
	\hphantom{\enskip}vector<pair<float128,float128>> statisticsList;{\color{gray}//vec(mean, std)}\\
	\hphantom{\enskip}vector<T> currentList;{\color{gray}//facets}\\
\};}
\code{class SimulationHistory \{\\
	public:\\
	\hphantom{\enskip}SimulationHistory();\\
	\hphantom{\enskip}SimulationHistory(Databuff *hitbuffer);\\
	[0.5\baselineskip]
	\hphantom{\enskip}HistoryList<uint\_128t> coveringList;{\color{gray}//covering}\\
	\hphantom{\enskip}HistoryList<llong> desorbedList;{\color{gray}//Number desorbed paticles}\\
	\hphantom{\enskip}HistoryList<double> hitList;{\color{gray}//MC hits}\\
	\hphantom{\enskip}HistoryList<double> errorList\_event;{\color{gray}//error event: hits \& desorbed particles}\\
	\hphantom{\enskip}HistoryList<double> errorList\_covering;{\color{gray}//error covering: desorbed \& adsorbed}\\
	\hphantom{\enskip}HistoryList<double> particleDensityList;\\
	\hphantom{\enskip}HistoryList<double> pressureList;\\
	[0.5\baselineskip]
	\hphantom{\enskip}double lastTime;\\
	\hphantom{\enskip}int currentStep;\\
\};}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Updated after each iteration in \codew{UpdateParticleDensityAndPressure($\cdot$)},\linebreak[4] \codew{UpdateCovering($\cdot$)}, \codew{UpdateErrorMain($\cdot$)} (\codew{UpdateMainProcess.cpp})
\item Recorded quantities: covering, error (event and covering), particle density and pressure for each facet and  iteration, total hits and desorbed particles for each facet
\item lastTime: simulated time (accumulated time steps) instead of computation time 
\end{itemize}

 \subsection{Simulation on subprocesses}
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance=2cm, font=\scriptsize]
	\tikzstyle{condition} = [diamond, draw, minimum width= 3.5cm, align=center,  aspect=1.5]
	\tikzstyle{module} = [ellipse,draw, minimum width= 3.5cm, align=center, aspect=1.5]
	\tikzstyle{neuron}= [rectangle,draw, minimum width= 3.5cm, align=center, aspect=1.5]
	\tikzstyle{dot}=[circle, fill = black, ,inner sep=1.1pt]]


	\node[module](start)  at (0,-0.2) {Start simulation\\sub process};
	\node[neuron](preprocess) at (6,-0.2) {Calculate desorption,\\outgassing,\\cov.\ thresh.\ \& step size;\\multiply cov.\ if small};
	\draw let \p1=(start.east), \p2=(preprocess.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](nbSteps) at (1,-1.9) {Calculate steps for \\desired simulation time};
	\draw let \p1=(preprocess.south), \p2=(nbSteps.east) in [->, line width=0.04cm] (\p1) --  (\x1,\y2)-- (\p2);

	\node[condition, aspect=1.5](exist) at (1,-3.65){Particle\\exists?};
	\draw let \p1=(nbSteps.south), \p2=(exist.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](particle) at (1,-5.5) {Create particle%\\Add residence time
	};
	\draw let \p1=(exist.south), \p2=(particle.north) in [->, line width=0.04cm] (\p1) -- (\p2)node[midway, right]{false};

	\node[neuron](time3) at (6,-5.5){Determine start time};
	%\node[condition, aspect=1.5](time3) at (6,-5.8){flight time$>$\\step size?};
	\draw let \p1=(particle.east), \p2=(time3.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[condition, aspect=1.5](covthresh) at (11,-5.5){Cov. thresh.\\reached?};
	\draw let \p1=(time3.east), \p2=(covthresh.west) in [->, line width=0.04cm] (\p1) -- (\p2);%node[midway, above]{false};
	\draw let \p1=(exist.east), \p2=(covthresh.north) in [->, line width=0.04cm] (\p1) --(\x1+1cm,\y1)node[midway, above]{true}--(\x2,\y1)-- (\p2);

	\node[condition, aspect=1.5](facet) at (6,-7.4) {Next facet\\found?};
	\draw let \p1=(covthresh.south), \p2=(facet.east) in [->, line width=0.04cm] (\p1) -- (\x1,\y2) node[midway, right]{false} --(\p2);
	\path let \p1=(covthresh.south), \p2=(facet.east) in node[dot] at (\x1,\y2){};

	\node[condition, aspect=1.5](time1) at (1,-9.2){flight time$>$\\step size?};
	\draw let \p1=(facet.west), \p2=(time1.north) in [->, line width=0.04cm] (\p1) -- ([xshift=-1cm]\p1)node[midway, above]{true} --  (\x2,\y1)--(\p2);

	\node[neuron](sojourn) at (6,-9.2) {Add residence time};
	\draw let \p1=(time1.east), \p2=(sojourn.west) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, above]{false};

	\node[condition, aspect=1.5](time2) at (6,-11.5){flight time$>$\\step size?};
	\draw let \p1=(sojourn.south), \p2=(time2.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](hit) at (6,-13.8) {Record hit};
	\draw let \p1=(time2.south), \p2=(hit.north) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, right]{false};
	\draw let \p1=(hit.east), \p2=(facet.east) in [ line width=0.04cm] (\p1) -- (11,\y1) -- (11,\y2) ;

	\node[neuron](absorb) at (1,-11.5) {Record absorb};
	\draw let \p1=(time1.south), \p2=(absorb.north) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, right]{true};
	\draw let \p1=(time2.west), \p2=(absorb.east) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, above]{true};
	%\draw let \p1=(time3.south),\p2=(absorb.west) in [->, line width=0.04cm](\p1) --(\x1,\y1-0.2cm) --node[midway, above]{true}(\x1-1.5cm,\y1-0.2cm)--(\x2-0.33cm,\y1-0.2cm)--(\x2-0.33cm,\y2)--(\p2);

	\node[condition, aspect=1.5](steps) at (1,-13.8){No.steps\\reached?};
	\path let \p1=(absorb.south) in node[dot](dotabs) at (\x1,\y1-0.6cm){};
	\draw let \p1=(absorb.south), \p2=(steps.north) in [->, line width=0.04cm] (\p1) -- (\p2);
	\draw let \p1=(facet.north), \p2=(dotabs) in [ line width=0.04cm] (\p1) --(\x1,\y1+0.2cm)--(\x1-1.5cm,\y1+0.2cm)node[midway, above]{false}--(\x2-2cm,\y1+0.2cm)--(\x2-2cm,\y2)--(\p2);
	\draw let \p1=(steps.west), \p2=(particle.west) in [->, line width=0.04cm] (\p1) --(\x1-0.66cm,\y1)-- node[midway, right]{false}(\x1-0.66cm,\y1+1cm)-- (\x1-0.66cm,\y2) -- (\p2);

	%\node[condition, aspect=1.5](steps2) at (11,-14.3){No.steps\\reached?};
	%\draw let \p1=(hit.east), \p2=(steps2.west) in [->, line width=0.04cm] (\p1) -- (\p2);
	%\draw let \p1=(steps2.north), \p2=(facet.east) in [ line width=0.04cm] (\p1) --node[midway, right]{false}(\x1,\y1+1cm)-- (\x1,\y2) -- (6, \y2);

	\node[condition, aspect=1.5](target) at (6,-16.7){Target error\\reached?};
	\draw let \p1=(steps.south), \p2=(target.north) in [->, line width=0.04cm] (\p1) --(\x1,\y1-0.3cm) --node[midway, above]{true}(\x1+2cm,\y1-0.3cm)--(\x2,\y1-0.3cm)-- (\p2);
	%\draw let \p1=(steps2.south), \p2=(target.north) in [ line width=0.04cm] (\p1) --(\x1,\y1-0.3cm) --node[midway, above]{true}(\x1-2cm,\y1-0.3cm)--(\x2,\y1-0.3cm);
	\draw let \p1=(target.west), \p2=(nbSteps.west) in [->, line width=0.04cm] (\p1) --node[midway, above]{false}(\x1-1cm, \y1)--(\x1-6cm,\y1)-- (\x1-6cm,\y2) -- (\p2);

	\node[neuron](hitbuffer) at (11,-1.9) {Update hitbuffer};
	\draw let \p1=(target.east), \p2=(hitbuffer.east) in [->, line width=0.04cm] (\p1) -- (\x1+1cm,\y1) node[midway, above]{true}--(\x1+6cm,\y1)--(\x1+6cm,\y2) -- (\p2);
	\draw let \p1=(covthresh.east) in [ line width=0.04cm] (\p1) -- (\x1+1cm,\y1) node[midway, above]{true};
	\path let \p1=(covthresh.east) in node[dot] at (\x1+1cm,\y1){};

	\node[module](end)  at (12,-0.2) {End simulation\\sub process};
	\draw let \p1=(hitbuffer.north), \p2=(end.south) in [->, line width=0.04cm] (\x2,\y1) -- (\p2);

\end{tikzpicture}
\caption{Overview: simulation on sub processes}
\end{figure}

\subsubsection{Calculate step size}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculation from \codew{simHistory$\rightarrow$currentStep} in \codew{getStepSize()} (\codew{UpdateMainProcess.cpp})
\end{itemize}

\subsubsection{Calculate covering threshold}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Set lower threshold for covering for each facet to prevent covering getting negative
\item Stop simulation once threshold is reached
\item Threshold set in \codew{setCoveringThreshold($\cdot$)} (\codew{Iteration.cpp})
\end{itemize}

\subsubsection{Multiply small covering}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Multiply covering so that smallest covering $\geq$ \codew{ProblemDef::coveringThreshMin}
\item Multiply covering threshold with same factor
\item Calculation in \codew{checkSmallCovering($\cdot$)} (\codew{SimulationLinux.cpp})
\end{itemize}

\subsubsection{Calculate desorption and outgassing}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Desorption from covering in \codew{UpdateDesorption($\cdot$)}  (\codew{UpdateSubProcess.cpp})
\item Outgassing in \codew{CalcTotalOutgassingWorker()} (\codew{Worker.cpp})
\end{itemize}

\subsubsection{Create particle and calculate start time}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Facet randomly selected based on total desorption and outgassing
\item Desorption or outgassing randomly selected based on ratio on facet
\item Start time randomly generated based on distribution of desorption or outgassing
\item Calculation in \codew{StartFromSource($\cdot$)}  (\codew{SimulationMC.cpp})
\end{itemize}

\subsubsection{Calculate residence time}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Residence time of a particle on a surface calculated from binding energy, coverage and thermal oscillation frequency
%\item Binding energy calculated using binding energy on pure substrate, vaporization enthalpy and coverage
%\item Thermal oscillation frequency calculated using temperature, Boltzmann constant and Planck's constant
%\item Calculation in \codew{UpdateSojourn($\cdot$)}  from \codew{UpdateSubProcess.cpp} file
\item Sojourn time randomly calculated from binding energy, facet temperature and sojourn frequency in \codew{PerformBounce($\cdot$)}  (\codew{SimulationMC.cpp})
\end{itemize}

\subsubsection{Increase facet counters in case of desorb, absorb or hit}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Increase hit, desorb or absorb counter according to event
\item Increase velocity counters only if event within \codew{p$\rightarrow$counterWindowPercent}
\item Facet counters increased in \codew{IncreaseFacetCounter($\cdot$)}  (\codew{SimulationMC.cpp})
\end{itemize}

\subsubsection{Target error reached?}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculate statistical error in \codew{UpdateError()} from \codew{UpdateSubProcess.cpp} file
\item Avg.\ error calculated from summing facet error weighted with facet area
\item Error to check can be either covering or event error (currently covering)
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Check if vip facets reached their own target error
\item Check if avg.\ error reached target error
\end{itemize}
\item Facets with error=$inf$ are not considered
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Facets that reached \codew{ProblemDef::hitRatioLimit}
\item Facets with no events or covering change
\item If vip facet: own target error automatically reached
\item If normal facet: facet error and area not used for calculation
\end{itemize}
\item Check in \codew{checkErrorSub($\cdot$)} (\codew{UpdateSubProcess.cpp})
\end{itemize}

\section{Update main buffer}
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance=2cm, font=\scriptsize]
	\tikzstyle{condition} = [diamond, draw, minimum width= 4cm, align=center,  aspect=1.5]
	\tikzstyle{module} = [ellipse,draw, minimum width= 4cm, align=center, aspect=1.5]
	\tikzstyle{neuron}= [rectangle,draw, minimum width= 4cm, align=center, aspect=1.5]

	\node[module](start)  at (0,-0.3) {Start update\\main process};

	%\node[neuron](small) at (0,-2.2) {Divide cov. if\\previously multiplied};
	%\draw let \p1=(start.south), \p2=(small.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](K) at (0,-1.8) {Calculate $K_{\text{real}/\text{virtual}}$};
	\draw let \p1=(start.south), \p2=(K.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](DP) at (0,-3.3) {Calculate pressure\\and particle density};
	\draw let \p1=(K.south), \p2=(DP.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](error) at (0,-5) {Calculate error of\\current iteration};
	\draw let \p1=(DP.south), \p2=(error.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	%\node[neuron](stepsize) at (0,-5) {Calculate step size\\from $currentStep$};
	%\draw let \p1=(error.south), \p2=(stepsize.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	%\node[condition](decrease) at (5,-5) {Step size\\decreased?};
	%\draw let \p1=(stepsize.east), \p2=(decrease.west) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[condition](target) at (4.8,-5) {Target error\\reached?};
	\draw let \p1=(error.east), \p2=(target.west) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, above] {false};

	\node[neuron, minimum width=3cm](increase) at (9.2,-5) {Increase\\$currentStep$};
	%\draw let \p1=(target.east), \p2=(increase.south) in [->, line width=0.04cm] (\p1) -- (\x2+0.5cm, \y1) node[midway, above] {true}--([xshift=0.5cm]\p2);
	\draw let \p1=(target.east), \p2=(increase.west) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway, above] {true};

	\node[neuron, minimum width=5cm](cov) at (7,-3.1) {Calculate real covering};
	%\draw let \p1=(decrease.north), \p2=(update.south) in [->, line width=0.04cm] (\p1) -- (\x1,\y2) node[midway, right] {true};
	\draw let \p1=(target.north), \p2=(cov.south) in [->, line width=0.04cm] (\p1) -- (\x1,\y2) node[midway, right] {false};
	\draw let \p1=(increase.north), \p2=(cov.south) in [->, line width=0.04cm] (\p1) -- (\x1,\y2);

	\node[neuron, minimum width=5cm](update) at (7,-2.0) {Update covering to\\ hitbuffer and simHistory};
	\draw let \p1=(cov.north), \p2=(update.south) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron, minimum width=5cm](statistics) at (7,-1.0) {Update statistics};
	\draw let \p1=(update.north), \p2=(statistics.south) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[module](end)  at (12,-0.3) {End update\\main process};
	\draw let \p1=(statistics.north), \p2=(end.west) in [->, line width=0.04cm] (\p1) -- (\x1,\y2) --(\p2);
\end{tikzpicture}
\caption{Overview: update of covering in hitbuffer}
\end{figure}

\subsubsection{Before summation of subprocesses}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculate step size in \codew{getStepSize()} (\codew{UpdateMainProcess.cpp})
\item Multiply covering in \codew{hitbuffer} of main process  analogous to sub processes in \codew{checkSmallCovering($\cdot$)} (\codew{SimulationLinux.cpp})
\end{itemize}

%\subsubsection{Divide small covering after  summation of subprocesses}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Division by the small covering factor will be done when converting virtual test particles into real, physical particles
%\item Then, \codew{hitbuffer} and \codew{hitbuffer\textunderscore sum} of main process will be overwritten with the real, physical values anyway. So there is no need to divide by the small covering factor.
%\end{itemize}

\subsubsection{Calculate pressure and particle density}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculation in \codew{UpdateParticleDensityAndPressure($\cdot$)} (UpdateMainProcess.cpp)
\item Values per facet saved in \codew{simHistory$\rightarrow$pressureList}/\codew{simHistory$\rightarrow$particleDensityList}
\end{itemize}

\subsubsection{Calculate error}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculation analogous to sub processes in \codew{UpdateErrorMain($\cdot$)} (\codew{UpdateMainProcess.cpp})
\item Save error per facet in \codew{simHistory$\rightarrow$errorList\_event}/\codew{simHistory$\rightarrow$errorList\_covering}
\item[]$\Rightarrow$ Increase \codew{simHistory$\rightarrow$currentStep} if target errors reached
\end{itemize}

%\subsubsection{Management of Step Size}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item Adapt step size if desorption $\times$ time step was larger than covering 
%\item Increase \codew{simHistory$\rightarrow$currentStep} if no adaptation \& target errors reached
%\item Management in \codew{manageStepSize($\cdot$)} from \codew{UpdateMainProcess.cpp} file
%\end{itemize}

\subsubsection{Calculate \& update covering}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item $K_{\text{real}/\text{virtual}}$ computed in \codew{GetMoleculesPerTP($\cdot$)} (\codew{Simulationcalc.cpp})
\item Divide covering in \codew{hitbuffer}  if previously multiplied
\item Use $K_{\text{real}/\text{virtual}}$ to calculate new covering
\item Save new covering in \codew{simHistory$\rightarrow$coveringList} and \codew{hitbuffer}
\item Calculation in \codew{UpdateCovering($\cdot$)} from \codew{UpdateMainProcess.cpp} file
\item Update buffers in \codew{UpdateCoveringPhys($\cdot$)} (\codew{UpdateMainProcess.cpp})
\end{itemize}

\subsubsection{Calculate \& update statistics}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Calculate mean and std of covering over last \codew{p$\rightarrow$rollingWindowSize} iterations
\item Update statistics in \codew{HistoryList::updateStatistics($\cdot$)} (\codew{SimulationLinux.h})
\item End simulation if \codew{p$\rightarrow$convergenceTarget} is reached by avg.\ statistics weighted with area which is calculated in \codew{HistoryList::getAverageStatistics($\cdot$)} (\codew{SimulationLinux.h})
\end{itemize}

%\newpage
\section{Summary}
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance=2cm, font=\scriptsize]
	\tikzstyle{condition} = [diamond, draw, minimum width= 4cm, align=center,  aspect=1.5]
	\tikzstyle{module} = [ellipse,draw, minimum width= 4cm, align=center, aspect=1.5]
	\tikzstyle{neuron}= [rectangle,draw, minimum width= 4cm, align=center, aspect=1.5]

	\node[module](start)  at (0,0.1) {Start\\Application};
	\node[neuron](smpi) at (0,-1.6) {Initialize MPI};
	\draw let \p1=(start.south), \p2=(smpi.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[module](preprocess) at (0,-2.9) {Initialization};
	\draw let \p1=(smpi.south), \p2=(preprocess.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[neuron](bcast) at (0,-4.8) {Main process:\\broadcast\\ simHistory$\rightarrow$coveringList\\ \& simHistory$\rightarrow$currentStep};
	\draw let \p1=(preprocess.south), \p2=(bcast.north) in [->, line width=0.04cm] (\p1) -- (\p2);

	\path let \p1=(bcast.east) in node[module](sim1) at (4.5,\y1+1.2cm) {Simulation\\sub process};
	\draw let \p1=(bcast.east), \p2=(sim1.west) in [->, line width=0.04cm] (\x1, \y1+0.4cm) -- (\p2);

	\path let \p1=(bcast.east) in node[module](sim2) at (4.5,\y1-1.2cm) {Simulation\\sub process};
	\draw let \p1=(bcast.east), \p2=(sim2.west) in [->, line width=0.04cm] (\x1, \y1-0.4cm) -- (\p2);

	\foreach \i in{-1,0,1}
		\draw[fill] let \p1=(sim1.south), \p2=(sim2.north) in (\x1,0.5*\y1+0.5*\y2+0.25cm*\i) circle [radius=0.06];

	\node[neuron, rotate=90, minimum height=1.4cm](sum) at (7.8,-4.8){Summarize results\\in main hitbuffer};
	\draw let \p1=(sim1.east), \p2=(sum.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1);
	\draw let \p1=(sim2.east), \p2=(sum.north) in [->, line width=0.04cm] (\p1) -- (\x2,\y1);

	\node[module](update) at (11,-6) {Update\\main process};
	\draw let \p1=(sum.south), \p2=(update.west) in [->, line width=0.04cm] (\x1,\y2) -- (\p2);

	\node[condition](max) at (11, -3.6) {Max. time or\\convergence\\target reached?};
	\draw let \p1=(update.north), \p2=(max.south) in [->, line width=0.04cm] (\p1) -- (\p2);
	\draw let \p1=(max.east), \p2=(bcast.south) in [->, line width=0.04cm] (\p1) --(\x1+1cm, \y1) node[midway,above]{false} --(\x1+1cm, \y2-1.5cm) --(\x2, \y2-1.5cm)-- (\p2);

	\node[neuron](save) at (11,-1.6) {Save results};
	\draw let \p1=(max.north), \p2=(save.south) in [->, line width=0.04cm] (\p1) -- (\p2) node[midway,right]{true};

	\node[neuron](empi) at (5.5,-1.6) {Finalize MPI};
	\draw let \p1=(save.west), \p2=(empi.east) in [->, line width=0.04cm] (\p1) -- (\p2);

	\node[module](end)  at (12,0.1) {End\\Application};
	\draw let \p1=(empi.north), \p2=(end.west) in [->, line width=0.04cm] (\p1)-- (\x1,\y2) -- (\p2);
	
\end{tikzpicture}
\caption{Overview: ContaminationFlow application}
\end{figure}
\newpage
\subsubsection{General Pipeline}
\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
\item Initialize MPI, \codew{ProblemDef p} and \codew{SimulationHistory simHistory}
\item Check if all simulation parameters are valid
\item Load geometry into \codew{Simulation sHandle} and check if values are valid using \codew{loadAndCheckSHandle()}
	\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
		\item[$\bullet$] Load geometry using \codew{LoadSimulation}
		\item[$\bullet$] Hitbuffer: import using  \codew{importBuff($\cdot$)} or initialize size using  \codew{initBuffSize($\cdot$)}
		\item[$\bullet$] Check for correct hitbuffer size
		\item[$\bullet$] Check for zero moments
		\item[$\bullet$] Check for no two-sided facets with opacity
		\item[$\bullet$] Check for valid covering file and import covering values
	\end{itemize}
\item Iteration until \codew{p$\rightarrow$maxTimeS} or\\ \codew{p$\rightarrow$convergenceTarget} (\codew{p$\rightarrow$convergenceTime},\codew{p$\rightarrow$stopConverged}) is reached: \smallskip
	\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
	\item[$\bullet$] Reset hitbuffer counters using \codew{initbufftotero($\cdot$)}
	\item[$\bullet$] Broadcast \codew{simHistory$\rightarrow$coveringList} using \codew{MPI\_Bcast($\cdot$)}
	\item[$\bullet$] Set covering threshold \codew{covthresh} using \codew{setCoveringThreshold($\cdot$)}
	\item[$\bullet$] Update relevant simulation values using \codew{simHistory$\rightarrow$updateStepSize($\cdot$)},\linebreak[4] \codew{UpdateSticking($\cdot$)}, \codew{CalcTotalOutgassingWorker($\cdot$)}, \codew{UpdateDesorption($\cdot$)}
	\item[$\bullet$] Multiply covering and \codew{covthresh} with \codew{simHistory$\rightarrow$smallCoveringFactor} if covering is small
	\item[$\bullet$] Simulation in sub processes
	\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
	\item[--] Simulate until \codew{targetParticles} and \codew{targetError} or \codew{covthresh} reached
	\item[--] Update hitbuffers of sub processes from \codew{sHandle} using \codew{UpdateSubHits($\cdot$)} (\codew{UpdateSubProcess.cpp})
	\end{itemize}
	\item[$\bullet$] Update Main process:
		\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
		\item[--] Send hitbuffer to main process using \codew{MPI\_Send($\cdot$)} and \codew{MPI\_Recv($\cdot$)}
		\item[--] Update of hitbuffer in \codew{UpdateMainHits($\cdot$)} (\codew{UpdateMainProcess.cpp})
		\end{itemize}
	\item [$\bullet$] Update pressure and particle density using \codew{UpdateParticleDensityAndPressure($\cdot$)} (UpdateMainProcess.cpp), save in \codew{simHistory}
	\item[$\bullet$] Update error of iteration using \codew{UpdateErrorMain($\cdot$)} (\codew{UpdateMainProcess.cpp}), save in \codew{simHistory}
	\item[$\bullet$] Calculate real covering in main process using $K_{\text{real}/\text{virtual}}$ in \codew{UpdateCovering($\cdot$)} (\codew{UpdateMainProcess.cpp}), save in \codew{simHistory}
	\item[$\bullet$] Update real covering in hitbuffer of main process in \codew{UpdateCoveringphys($\cdot$)} (\codew{UpdateMainProcess.cpp})
	\item[$\bullet$] Update statistics using \codew{simHistory$\rightarrow$coveringList.updateStatistics($\cdot$)}
	\end{itemize}\smallskip
\item Export final results (\codew{simHistory} lists) to results folder
\item Close MPI
\end{itemize}
\newpage




%\subsubsection{Thats changed}
%\begin{itemize}[noitemsep,topsep=0pt, partopsep=0pt]
%\item use this for 
%\item list
%\end{itemize}


